<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VOXIN Â· æµ…è‰²ç‰ˆ</title>
  <style>
    :root{
      --bg:#ffffff;          /* é¡µé¢èƒŒæ™¯ */
      --card:#f8fafc;        /* å¡ç‰‡èƒŒæ™¯ */
      --soft:#e5e7eb;        /* æŸ”å’Œåˆ†éš”çº¿ */
      --text:#0f172a;        /* ä¸»æ–‡å­— */
      --muted:#475569;       /* æ¬¡çº§æ–‡å­— */
      --accent:#2563eb;      /* ä¸»æŒ‰é’®/é«˜äº® */
      --accent2:#06b6d4;     /* é¢‘è°±è‰²ï¼ˆå·²ç”¨äºåœ†ç¯å³ä¾§ï¼‰ */
      --danger:#ef4444;      /* å±é™©è‰² */
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:8px 0 6px}
    .sub{color:var(--muted);font-size:13px}
    .card{background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 2px 14px rgba(15,23,42,.06);padding:12px;overflow: hidden;}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button,select,input[type=range]{appearance:none;border:none}
    button{padding:10px 14px;border-radius:12px;color:#fff;background:var(--accent);font-weight:600;cursor:pointer}
    button.secondary{background:#e2e8f0;color:#0f172a}
    button.danger{background:var(--danger);color:#fff}
    button.ghost{background:transparent;color:var(--muted);border:1px solid var(--soft)}
    button:disabled{opacity:.6}
    select{padding:10px;border-radius:10px;background:#f1f5f9;color:#0f172a;border:1px solid var(--soft)}
    label{font-size:13px;color:var(--muted)}
    .slider{width:100%}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    .hint{font-size:12px;color:#64748b}
    .pill{display:inline-block;font-size:12px;padding:4px 8px;border-radius:999px;background:#eef2f7;border:1px solid #d1d5db;color:#0f172a}
    canvas{display:block;width:100%;height:200px;border-radius:12px;background:#f1f5f9;border:1px solid var(--soft)}
    .badge{font-size:12px;color:#334155}
    .footer{font-size:12px;color:#64748b;text-align:center;margin-top:16px}
    @media (min-width:720px){canvas#wave{height:260px}}

    /* ç„¦ç‚¹å¯è§æ€§ */
    button:focus,select:focus,input:focus{outline:3px solid rgba(37,99,235,.35);outline-offset:2px}

    /* â€”â€” å¼¹çª— â€”â€” */
    .modal{position:fixed;inset:0;background:rgba(15,23,42,.45);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
    .modal[aria-hidden="false"]{display:flex}
    .modal-card{width:100%;max-width:460px;background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,.2);padding:16px}
    .modal-card h3{margin:4px 0 6px;font-size:18px}
    .modal-card p{margin:0 0 10px;color:var(--muted)}

    /* â€”â€” æ–°ï¼šåŒåœ†ç¯å®¹å™¨ï¼ˆæ›¿æ¢åŸè°±å›¾ä½ç½®ï¼‰ â€”â€” */
    .ring-wrap{
      display:grid;
      grid-template-columns:1fr 1fr;
      gap:12px;
      align-items:stretch;
    }
    .ring{
      display:flex;
      align-items:center;
      justify-content:center;
      background:#f1f5f9;
      border:1px solid var(--soft);
      border-radius:12px;
      /* ç”¨æ­£æ–¹å½¢æ¯”ä¾‹é¿å…æ¨ªå‘æ‹‰ä¼¸ */
      aspect-ratio: 1 / 1;
      width: 100%;
      /* å¯é€‰æœ€å°é«˜åº¦ï¼Œé¿å…å¤ªå° */
      min-height: 180px;
    }

    /* å…³é”®ç‚¹ï¼šä¸è¦ç”¨ 100%/100% æ‹‰ canvasï¼ */
    .ring canvas{
      background:transparent;
      border:none;
      border-radius:12px;
      /* è®©å°ºå¯¸äº¤ç»™ JS æ¥è®¾å®š */
      width:auto;
      height:auto;
      display:block;
    }

  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>VOXIN - å¼€å¯ä½ çš„å£°éŸ³è®­ç»ƒä¹‹æ—…å§ï¼ğŸ¤âœ¨ğŸš€</h1>
      <div class="sub">
        <span id="supportHint" class="hint" style="display:block;margin-top:4px"></span>
      </div>
    </header>

    <section class="card" id="displayCard">
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <span class="badge" id="sr">é‡‡æ ·ç‡: â€”</span>
        <span class="pill" id="peak">å³°å€¼: 0%</span>
      </div>
      <canvas id="wave"></canvas>

      <!-- â–¼â–¼â–¼ æ›¿æ¢æ‰åŸå…ˆçš„ spectrumï¼šåŒåœ†ç¯ â–¼â–¼â–¼ -->
      <div class="ring-wrap" style="margin-top:12px">
        <div class="ring"><canvas id="ringJitter" aria-label="jitter_local_percent"></canvas></div>
        <div class="ring"><canvas id="ringShimmer" aria-label="shimmer_local_percent"></canvas></div>
      </div>
      <!-- â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² -->
    </section>

    <section class="grid" style="margin-top:12px">
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button id="toggle">å¼€å§‹</button>
            <button class="secondary" id="reenum">åˆ·æ–°è®¾å¤‡</button>
          </div>
          <div class="badge" id="ctxState"></div>
        </div>

        <div style="height:8px"></div>
        <div class="row">
          <label for="mics">éº¦å…‹é£</label>
          <select id="mics"></select>
        </div>

        <div class="row" style="gap:16px;margin-top:8px">
          <div style="flex:1;min-width:140px">
            <label>å¹³æ»‘ (smoothing) <span id="smoothingVal" class="badge">0.50</span></label>
            <input class="slider" id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.5" />
          </div>
          <div style="flex:1;min-width:140px">
            <label>å¢ç›Š (gain) <span id="gainVal" class="badge">1.0</span></label>
            <input class="slider" id="gain" type="range" min="0.1" max="3" step="0.1" value="1" />
          </div>
          <div style="flex:1;min-width:140px">
            <label>æ³¢å½¢ç¼©æ”¾ (scope) <span id="scopeVal" class="badge">1.00Ã—</span></label>
            <input class="slider" id="scope" type="range" min="0.25" max="100" step="0.25" value="50" />
          </div>
        </div>
      </div>
    </section>

    <div class="footer">Â© <span id="year"></span> VOXIN Demo</div>
  </div>

  <!-- ç»“æœå¼¹çª—ï¼šä¸‹è½½ / ä¸Šä¼  -->
  <div class="modal" id="resultModal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-card">
      <h3 id="modalTitle">å½•éŸ³å®Œæˆ âœ…</h3>
      <div style="margin:10px 0">
        <label for="filenameInput" class="hint">è¯·è¾“å…¥æ–‡ä»¶å(ä¾‹å¦‚ï¼šjack_pre, jack_post)</label>
        <input type="text" id="filenameInput" placeholder="æ–‡ä»¶å" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:8px;font-size:14px;margin-top:4px" />
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="secondary" id="btnUpload">ä¸Šä¼ </button>
        <button id="btnDownload">ä¸‹è½½</button>
      </div>
      <div id="uploadStatus" class="hint" style="margin-top:8px"></div>
    </div>
  </div>

<script>
(function(){
  // ===== Polyfill: æ—§ç‰ˆæµè§ˆå™¨çš„ getUserMedia =====
  (function ensureGetUserMedia(){
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => { console.log("éº¦å…‹é£é‡‡é›†æˆåŠŸ", stream); })
        .catch(err => { console.error("éº¦å…‹é£é‡‡é›†å¤±è´¥:", err); });
    } else {
      console.error("è¯¥æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£é‡‡é›†");
    }
  })();

  const dpr = window.devicePixelRatio || 1;
  const wave = document.getElementById('wave');
  const ringJitter = document.getElementById('ringJitter');
  const ringShimmer = document.getElementById('ringShimmer');
  const toggleBtn = document.getElementById('toggle');
  const reenumBtn = document.getElementById('reenum');
  const micsSel = document.getElementById('mics');
  const smoothingInp = document.getElementById('smoothing');
  const gainInp = document.getElementById('gain');
  const smoothingVal = document.getElementById('smoothingVal');
  const gainVal = document.getElementById('gainVal');
  const scopeInp = document.getElementById('scope');
  const scopeVal = document.getElementById('scopeVal');
  const srEl = document.getElementById('sr');
  const peakEl = document.getElementById('peak');
  const ctxState = document.getElementById('ctxState');
  const yearEl = document.getElementById('year');
  const supportHint = document.getElementById('supportHint');
  yearEl.textContent = new Date().getFullYear();

  // â€”â€” å¼¹çª—å…ƒç´  â€”â€” 
  const modal = document.getElementById('resultModal');
  const btnDownload = document.getElementById('btnDownload');
  const btnUpload = document.getElementById('btnUpload');
  const uploadStatus = document.getElementById('uploadStatus');
  const filenameInput = document.getElementById('filenameInput');

  // â€”â€” å½•éŸ³å™¨ â€”â€” 
  let mediaRecorder = null;
  let lastRecording = null; // { blob, mime, filename }

  let ac = null, analyser = null, gainNode = null, src = null, stream = null, raf = null;

  // â€”â€” ç¯å½¢ç¼“å†²ï¼ˆå†å²æ³¢å½¢ï¼‰ï¼Œé»˜è®¤ 30 ç§’ â€”â€” 
  let windowSec = 30;
  let ring = null, ringLen = 0, writeIdx = 0, totalWritten = 0, tdFloat = null;

  // â€”â€” åœ†ç¯çŠ¶æ€ â€”â€” 
  const state = {
    jitterPercent: 0,   // 0-?
    shimmerPercent: 0,  // 0-?
    ewmaJ: 0,
    ewmaS: 0
  };

  // åŸºç¡€ç¯å¢ƒæç¤º
  const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if (!isSecure) {
    supportHint.textContent = 'âš ï¸ éå®‰å…¨ç¯å¢ƒï¼šè¯·ä½¿ç”¨ HTTPS æˆ– localhostã€‚';
  }

  function resizeCanvas(c){
    const rect = c.parentElement ? c.parentElement.getBoundingClientRect() : {width: c.clientWidth};
    const cssW = Math.floor(rect.width);
    const cssH = Math.max(160, Math.floor(cssW * 0.4));
    if (c === wave) {
      c.style.height = cssH + 'px';
    }
    c.width  = Math.floor((c === wave ? cssW : Math.min(cssW, 360)) * dpr);
    c.height = Math.floor((c === wave ? Math.max(160, Math.floor(cssW * 0.4)) : Math.min(c.parentElement.clientHeight, 420)) * dpr);
  }

  function resizeRing(c){
    const rect = c.parentElement.getBoundingClientRect();
    // å–æ­£æ–¹å½¢è¾¹é•¿ï¼ˆCSSåƒç´ ï¼‰
    const sizeCss = Math.floor(Math.min(rect.width, rect.height));

    // åŒæ­¥è®¾ç½®â€œå±•ç¤ºå°ºå¯¸â€ï¼ˆCSSåƒç´ ï¼‰
    c.style.width  = sizeCss + 'px';
    c.style.height = sizeCss + 'px';

    // è®¾ç½®â€œç»˜å›¾åƒç´ â€ï¼ˆç‰©ç†åƒç´ ï¼‰ï¼Œé¿å…æ¨¡ç³Šä¸æ‹‰ä¼¸
    const dpr = window.devicePixelRatio || 1;
    c.width  = Math.floor(sizeCss * dpr);
    c.height = Math.floor(sizeCss * dpr);

    // å¯é€‰ï¼šè‹¥ä½ åœ¨ drawRing é‡Œç”¨åˆ°çº¿å®½ç­‰ï¼ŒæŒ‰ DPR è°ƒæ•´ï¼š
    // const ctx = c.getContext('2d');
    // ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // ç„¶åæŒ‰ CSS åƒç´ ä½œå›¾
  }


  const onResize = ()=>{
    resizeCanvas(wave);
    resizeRing(ringJitter);
    resizeRing(ringShimmer);
  };
  window.addEventListener('resize', onResize);
  onResize();

  async function enumerate(){
    if (!(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)) {
      micsSel.innerHTML = '<option value="">é»˜è®¤éº¦å…‹é£ï¼ˆè®¾å¤‡åˆ‡æ¢ä¸å¯ç”¨ï¼‰</option>';
      return;
    }
    try{
      const tmp = await navigator.mediaDevices.getUserMedia({audio:true});
      tmp.getTracks().forEach(t=>t.stop());
      const list = await navigator.mediaDevices.enumerateDevices();
      const mics = list.filter(d=>d.kind==='audioinput');
      const opts = mics.map((d,i)=>`<option value="${d.deviceId||''}">${d.label||`éº¦å…‹é£ ${i+1}`}</option>`).join('');
      micsSel.innerHTML = opts || '<option value="">é»˜è®¤éº¦å…‹é£ï¼ˆæœªåˆ—å‡ºè®¾å¤‡ï¼‰</option>';
    }catch(e){
      micsSel.innerHTML='<option value="">é»˜è®¤éº¦å…‹é£</option>';
    }
  }
  enumerate();

  function getTimestamp() {
    const d = new Date();
    const pad = n => n.toString().padStart(2, '0');
    return [
      d.getFullYear(),
      pad(d.getMonth() + 1),
      pad(d.getDate()),
      pad(d.getHours()),
      pad(d.getMinutes()),
      pad(d.getSeconds())
    ].join('_');
  }

  // ===== ä¼°è®¡ Jitter/Shimmerï¼ˆåŸºäºæœ€è¿‘1ç§’ï¼Œç®€åŒ–æ³•ï¼‰ =====
  function estimateMetrics(rbuf, writeIdx, sr){
    const secs = 1.0; // æœ€è¿‘ 1 ç§’
    const N = Math.min(rbuf.length, Math.floor(sr * secs));
    if (N < 1024) return { jitterP: 0, shimmerP: 0, ok:false };

    const buf = new Float32Array(N);
    // æ‹·è´æœ€è¿‘ N ä¸ªæ ·æœ¬
    let start = (writeIdx - N + rbuf.length) % rbuf.length;
    for (let i=0; i<N; i++){
      buf[i] = rbuf[(start + i) % rbuf.length];
    }

    // è¿‡é›¶ï¼ˆè´Ÿ->æ­£ï¼‰ä½œä¸ºå‘¨æœŸè¾¹ç•Œ
    const zeroIdx = [];
    for (let i=1; i<N; i++){
      if (buf[i-1] < 0 && buf[i] >= 0) zeroIdx.push(i);
    }
    if (zeroIdx.length < 4) return { jitterP: 0, shimmerP: 0, ok:false };

    // å‘¨æœŸæ ·æœ¬æ•°
    const periods = [];
    // æ¯å‘¨æœŸå³°-å³°æŒ¯å¹…è¿‘ä¼¼ï¼ˆmax(|x|)ï¼‰
    const cycleAmps = [];

    for (let k=1; k<zeroIdx.length; k++){
      const a = zeroIdx[k-1], b = zeroIdx[k];
      const len = b - a;
      if (len <= 2) continue;
      periods.push(len);

      // å‘¨æœŸå†…æŒ¯å¹…
      let maxAbs = 0;
      for (let i=a; i<b; i++){
        const av = Math.abs(buf[i]);
        if (av > maxAbs) maxAbs = av;
      }
      cycleAmps.push(maxAbs + 1e-9);
    }

    if (periods.length < 3 || cycleAmps.length < 3){
      return { jitterP: 0, shimmerP: 0, ok:false };
    }

    const mean = arr => arr.reduce((s,v)=>s+v,0)/arr.length;
    const mP = mean(periods);
    const mA = mean(cycleAmps);
    const std = (arr,m)=>Math.sqrt(arr.reduce((s,v)=>s+(v-m)*(v-m),0)/arr.length);

    const jLocal = std(periods, mP) / mP;          // ç›¸å¯¹å‘¨æœŸåå·®
    const sLocal = std(cycleAmps, mA) / mA;        // ç›¸å¯¹æŒ¯å¹…åå·®

    // ç™¾åˆ†æ•°ï¼ˆé™åˆ¶ä¸Šé™ç”¨äºè¡¨ç›˜æ˜¾ç¤ºï¼‰
    return {
      jitterP: Math.min(10, Math.max(0, jLocal * 100)),
      shimmerP: Math.min(10, Math.max(0, sLocal * 100)),
      ok: true
    };
  }

  // ===== åœ†ç¯ç»˜åˆ¶ =====
  function drawRing(canvas, value, label, color){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;
    const r = Math.min(W, H) * 0.36;
    const lw = Math.max(8, Math.round(r*0.22));

    ctx.clearRect(0,0,W,H);

    // èƒŒæ™¯ç¯
    ctx.lineCap = 'round';
    ctx.lineWidth = lw;
    ctx.strokeStyle = '#e2e8f0';
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI*0.75, Math.PI*0.75);
    ctx.stroke();

    // æ•°å€¼ç¯ï¼ˆ0~30%æ˜ å°„åˆ° 270Â°ï¼‰
    const maxP = 30; // ç»éªŒä¸Šé™ï¼Œé¿å…ä¸€å‘æ•£å°±é“ºæ»¡
    const ratio = Math.max(0, Math.min(1, value / maxP));
    const start = -Math.PI*0.75;
    const end = start + ratio * (Math.PI*1.5);

    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.arc(cx, cy, r, start, end);
    ctx.stroke();

    // ä¸­å¿ƒæ–‡å­—
    ctx.fillStyle = '#0f172a';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // æ•°å­—
    const valStr = value.toFixed(2) + '%';
    ctx.font = Math.round(r*0.4) + 'px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(valStr, cx, cy - r*0.05);

    // æ ‡ç­¾
    ctx.fillStyle = '#475569';
    ctx.font = Math.round(r*0.2) + 'px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(label, cx, cy + r*0.6);
  }

  async function start(){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæˆ–æœªå¯ç”¨éº¦å…‹é£é‡‡é›†ï¼ˆç¼ºå°‘ navigator.mediaDevices.getUserMediaï¼‰ã€‚è¯·å‡çº§ç³»ç»Ÿ/æµè§ˆå™¨ï¼Œæˆ–æ”¹ç”¨ Safari/ç³»ç»Ÿæµè§ˆå™¨ã€‚');
      return;
    }

    toggleBtn.disabled = true;
    try{
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        throw new Error('æ­¤æµè§ˆå™¨ä¸æ”¯æŒ Web Audio APIï¼ˆç¼ºå°‘ AudioContextï¼‰ã€‚');
      }

      ac = new AudioCtx();
      if(ac.state==='suspended') await ac.resume();
      ctxState.textContent=ac.state;
      ac.onstatechange = (e) => {
        if (ctxState && e && e.target) ctxState.textContent = e.target.state;
      };

      const baseConstraints = { audio: true };
      let constraints = baseConstraints;

      const canSelectDevice = !!(micsSel && micsSel.value && micsSel.value !== '');
      if (canSelectDevice) {
        constraints = {
          audio: {
            deviceId: { exact: micsSel.value },
            echoCancellation:false, noiseSuppression:false, autoGainControl:false
          }
        };
      } else {
        constraints = { audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false } };
      }

      try { stream = await navigator.mediaDevices.getUserMedia(constraints); }
      catch (err) { stream = await navigator.mediaDevices.getUserMedia(baseConstraints); }

      src = ac.createMediaStreamSource(stream);
      analyser = ac.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = parseFloat(smoothingInp.value);

      gainNode = ac.createGain();
      gainNode.gain.value = parseFloat(gainInp.value);

      src.connect(gainNode).connect(analyser);

      srEl.textContent = 'é‡‡æ ·ç‡: ' + ac.sampleRate + ' Hz';

      // åˆå§‹åŒ–ç¯å½¢ç¼“å†²
      ringLen = Math.ceil(ac.sampleRate * windowSec * 1.2);
      ring = new Float32Array(ringLen);
      writeIdx = 0; totalWritten = 0;
      tdFloat = new Float32Array(analyser.fftSize);
      const fd = new Uint8Array(analyser.frequencyBinCount); // ä»ç”¨äºå³°å€¼ç²—ä¼°

      function draw(){
        const wctx = wave.getContext('2d');
        const W = wave.width, H = wave.height;

        // çº¿å®½è·Ÿéš DPR
        wctx.lineWidth = Math.max(1, dpr);

        // èƒŒæ™¯ä¸ä¸­çº¿ï¼ˆæµ…è‰²ï¼‰
        wctx.clearRect(0,0,W,H);
        wctx.fillStyle = '#ffffff'; wctx.fillRect(0,0,W,H);
        wctx.strokeStyle = '#cbd5e1'; wctx.beginPath(); wctx.moveTo(0,H/2); wctx.lineTo(W,H/2); wctx.stroke();

        // æ”¶é›†ä¸€å¸§
        analyser.getFloatTimeDomainData(tdFloat);
        let pk = 0;
        for (let i = 0; i < tdFloat.length; i++) {
          const v = tdFloat[i];
          ring[writeIdx] = v;
          writeIdx = (writeIdx + 1) % ringLen;
          totalWritten++;
          if (Math.abs(v) > pk) pk = Math.abs(v);
        }
        peakEl.textContent = 'å³°å€¼: ' + Math.min(100, Math.round(pk * 100)) + '%';

        // å›ºå®šç›®æ ‡çª—å£
        const targetSamples = Math.floor(ac.sampleRate * windowSec);
        const available = Math.min(totalWritten, targetSamples);
        const stride = Math.max(1, Math.floor(targetSamples / W));
        let startIdx = (writeIdx - available + ringLen) % ringLen;
        const visibleCols = Math.max(1, Math.floor(available / stride));
        const offsetX = W - visibleCols;
        const scope = scopeInp ? parseFloat(scopeInp.value) : 1;

        // æ³¢å½¢ï¼ˆç«–æ¡ï¼‰
        wctx.strokeStyle = '#2563eb';
        wctx.beginPath();
        for (let x = offsetX; x < W; x++) {
          let min =  1, max = -1;
          for (let k = 0; k < stride; k++) {
            const idx = (startIdx + (x - offsetX) * stride + k) % ringLen;
            let v = ring[idx] * scope;
            if (v >  1) v =  1;
            if (v < -1) v = -1;
            if (v < min) min = v;
            if (v > max) max = v;
          }
          const y1 = (1 - (max + 1) / 2) * H;
          const y2 = (1 - (min + 1) / 2) * H;
          wctx.moveTo(x, y1);
          wctx.lineTo(x, y2);
        }
        wctx.stroke();

        // === ä¼°è®¡ Jitter & Shimmerï¼Œå¹¶ç»˜åˆ¶ä¸¤ä¸ªåœ†ç¯ ===
        const { jitterP, shimmerP, ok } = estimateMetrics(ring, writeIdx, ac.sampleRate);

        // ç®€å•å¹³æ»‘ï¼ˆEWMAï¼‰é¿å…è·³åŠ¨
        const alpha = 0.2;
        if (ok){
          state.ewmaJ = alpha * jitterP + (1-alpha) * (state.ewmaJ || jitterP);
          state.ewmaS = alpha * shimmerP + (1-alpha) * (state.ewmaS || shimmerP);
          state.jitterPercent = state.ewmaJ;
          state.shimmerPercent = state.ewmaS;
        }

        // ç”»åœ†ç¯
        drawRing(ringJitter, state.jitterPercent || 0, 'Jitter', '#2563eb');
        drawRing(ringShimmer, state.shimmerPercent || 0, 'Shimmer', '#06b6d4');

        raf = requestAnimationFrame(draw);
      }

      raf = requestAnimationFrame(draw);
      toggleBtn.textContent = 'åœæ­¢';

      // å½•éŸ³èƒ½åŠ›
      if ('MediaRecorder' in window) {
        let chunks = [];
        try{
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' }, { bitsPerSecond: 128000 });
          chunks = [];
          mediaRecorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };
          mediaRecorder.onstop = () => {
            if (!chunks.length) {
              showModal();
              return;
            }
            const mime = mediaRecorder.mimeType || 'audio/webm';
            const blob = new Blob(chunks, {type: mime});
            const ts = new Date().toISOString().replace(/[:.]/g,'-');
            const filename = `record-${ts}.${mime.includes('webm') ? 'webm' : mime.split('/')[1] || 'dat'}`;
            lastRecording = { blob, mime, filename };
            showModal();
          };
          mediaRecorder.start();
        }catch(err){ alert('å½•éŸ³å¯åŠ¨å¤±è´¥ï¼š' + (err.message || err)); }
      } else {
        console.log('å½“å‰ç¯å¢ƒä¸æ”¯æŒ MediaRecorderï¼ˆiOS è€ç‰ˆæœ¬å¸¸è§ï¼‰');
      }

    }catch(e){
      alert((e && e.message) ? e.message :
            'å¯åŠ¨å¤±è´¥ï¼Œå¯èƒ½æ˜¯æœªæˆæƒéº¦å…‹é£ã€é HTTPSã€æˆ–æµè§ˆå™¨ä¸å…¼å®¹ã€‚');
      stop();
    }finally{
      toggleBtn.disabled = false;
    }
  }

  async function stop(){
    cancelAnimationFrame(raf); raf = null;
    try{ if (gainNode) gainNode.disconnect(); }catch(_){}
    try{ if (analyser) analyser.disconnect(); }catch(_){}
    try{ if (src) src.disconnect(); }catch(_){}
    try{ if (stream){ stream.getTracks().forEach(t=>t.stop()); } }catch(_){}
    try{
      if (ac){
        ac.onstatechange = null;
        await ac.close();
      }
    }catch(_){}

    ac = null; analyser = null; gainNode = null; src = null; stream = null;

    ctxState.textContent='';
    toggleBtn.textContent='å¼€å§‹';
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    } else {
      showModal();
    }
  }

  // â€”â€” å¼¹çª—é€»è¾‘ â€”â€” 
  function showModal(){
    modal.setAttribute('aria-hidden','false');
    uploadStatus.textContent = '';
    btnDownload.disabled = !lastRecording;
  }
  function hideModal(){ modal.setAttribute('aria-hidden','true'); }

  // ä¸‹è½½å½“å‰å½•éŸ³
  btnDownload.addEventListener('click', () => {
    if (!lastRecording) { alert('æ²¡æœ‰å¯ä¸‹è½½çš„å½•éŸ³ã€‚'); return; }
    if (!filenameInput.value.trim()) { alert('è¯·è¾“å…¥æ–‡ä»¶åã€‚'); return; }
    const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.webm`;

    const { blob } = lastRecording;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = input_filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  // ä¸Šä¼ å½“å‰å½•éŸ³ï¼ˆè¯·æ›¿æ¢ä¸ºä½ çš„ä¸Šä¼ æ¥å£ï¼‰
  btnUpload.addEventListener('click', async () => {
    try{
      if (!lastRecording) { alert('æ²¡æœ‰å¯ä¸Šä¼ çš„å½•éŸ³ã€‚'); return; }
      if (!filenameInput.value.trim()) { alert('è¯·è¾“å…¥æ–‡ä»¶åã€‚'); return; }
      const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.webm`;

      uploadStatus.textContent = 'æ­£åœ¨ä¸Šä¼ â€¦';
      const ENDPOINT = 'https://43.136.55.43/api/upload';
      const { blob, mime } = lastRecording;
      const fd = new FormData();
      fd.append('file', blob, input_filename);
      fd.append('mime', mime);
      const res = await fetch(ENDPOINT, { method:'POST', body: fd });
      if (!res.ok) throw new Error('ä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š' + res.status);
      const text = await res.text().catch(()=> '');
      console.log('ä¸Šä¼ å“åº”:', text);
      uploadStatus.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
    }catch(err){
      uploadStatus.textContent = 'ä¸Šä¼ å¤±è´¥ï¼š' + (err && err.message ? err.message : err);
    }
  });

  modal.addEventListener('click', (e)=>{ if(e.target===modal) hideModal(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideModal(); });

  toggleBtn.addEventListener('click',()=>{ if(ac) stop(); else start(); });
  reenumBtn.addEventListener('click',enumerate);

  smoothingInp.addEventListener('input',()=>{
    const v = parseFloat(smoothingInp.value);
    smoothingVal.textContent = v.toFixed(2);
    if(analyser) analyser.smoothingTimeConstant = v;
  });
  gainInp.addEventListener('input',()=>{
    const v = parseFloat(gainInp.value);
    gainVal.textContent = v.toFixed(1);
    if(gainNode) gainNode.gain.value = v;
  });
  scopeInp && scopeInp.addEventListener('input', () => {
    const v = parseFloat(scopeInp.value);
    scopeVal.textContent = v.toFixed(2) + 'Ã—';
  });
})();
</script>
</body>
</html>
