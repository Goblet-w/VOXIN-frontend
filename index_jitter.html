<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VOXIN · 浅色版（Jitter 实时版 · 连续波形）</title>
  <style>
    :root{
      --bg:#ffffff;          /* 页面背景 */
      --card:#f8fafc;        /* 卡片背景 */
      --soft:#e5e7eb;        /* 柔和分隔线 */
      --text:#0f172a;        /* 主文字 */
      --muted:#475569;       /* 次级文字 */
      --accent:#2563eb;      /* 主按钮/高亮 */
      --accent2:#06b6d4;     /* 频谱色 */
      --danger:#ef4444;      /* 危险色 */
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:8px 0 6px}
    .sub{color:var(--muted);font-size:13px}
    .card{background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 2px 14px rgba(15,23,42,.06);padding:12px;overflow: hidden;}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button,select,input[type=range]{appearance:none;border:none}
    button{padding:10px 14px;border-radius:12px;color:#fff;background:var(--accent);font-weight:600;cursor:pointer}
    button.secondary{background:#e2e8f0;color:#0f172a}
    button.danger{background:var(--danger);color:#fff}
    button.ghost{background:transparent;color:var(--muted);border:1px solid var(--soft)}
    button:disabled{opacity:.6}
    select{padding:10px;border-radius:10px;background:#f1f5f9;color:#0f172a;border:1px solid var(--soft)}
    label{font-size:13px;color:var(--muted)}
    .slider{width:100%}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    .hint{font-size:12px;color:#64748b}
    .pill{display:inline-block;font-size:12px;padding:4px 8px;border-radius:999px;background:#eef2f7;border:1px solid #d1d5db;color:#0f172a}
    canvas{display:block;width:100%;height:200px;border-radius:12px;background:#f1f5f9;border:1px solid var(--soft)}
    .badge{font-size:12px;color:#334155}
    .footer{font-size:12px;color:#64748b;text-align:center;margin-top:16px}
    @media (min-width:720px){canvas{height:260px}}
    /* 焦点可见性 */
    button:focus,select:focus,input:focus{outline:3px solid rgba(37,99,235,.35);outline-offset:2px}

    /* —— 弹窗 —— */
    .modal{position:fixed;inset:0;background:rgba(15,23,42,.45);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
    .modal[aria-hidden="false"]{display:flex}
    .modal-card{width:100%;max-width:460px;background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,.2);padding:16px}
    .modal-card h3{margin:4px 0 6px;font-size:18px}
    .modal-card p{margin:0 0 10px;color:var(--muted)}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>VOXIN - 开启你的声音训练之旅吧！🎤✨🚀</h1>
      <div class="sub">
        <span id="supportHint" class="hint" style="display:block;margin-top:4px"></span>
      </div>
    </header>

    <section class="card" id="displayCard">
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <span class="badge" id="sr">采样率: —</span>
        <span class="pill" id="peak">jitter_local_percent: —</span>
      </div>
      <!-- 用 Jitter 曲线替代原始波形（连续模式：静音也缓慢滑动） -->
      <canvas id="jitter" aria-label="Jitter(%) 实时曲线"></canvas>
      <div style="height:10px"></div>
      <canvas id="spectrum" aria-label="频谱图"></canvas>
    </section>

    <section class="grid" style="margin-top:12px">
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button id="toggle">开始</button>
            <button class="secondary" id="reenum">刷新设备</button>
          </div>
          <div class="badge" id="ctxState"></div>
        </div>

        <div style="height:8px"></div>
        <div class="row">
          <label for="mics">麦克风</label>
          <select id="mics"></select>
        </div>

        <div class="row" style="gap:16px;margin-top:8px">
          <div style="flex:1;min-width:140px">
            <label>平滑 (smoothing) <span id="smoothingVal" class="badge">0.50</span></label>
            <input class="slider" id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.5" />
          </div>
          <div style="flex:1;min-width:140px">
            <label>增益 (gain) <span id="gainVal" class="badge">1.0</span></label>
            <input class="slider" id="gain" type="range" min="0.1" max="3" step="0.1" value="1" />
          </div>
          <!-- 控制 “Jitter 视窗上限(%)”，默认 10% -->
          <div style="flex:1;min-width:140px">
            <label>Jitter 视窗上限 (%) <span id="scopeVal" class="badge">10.00%</span></label>
            <input class="slider" id="scope" type="range" min="5" max="20" step="0.5" value="10" />
          </div>
        </div>
      </div>
    </section>

    <div class="footer">© <span id="year"></span> VOXIN Demo</div>
  </div>

  <!-- 结果弹窗：下载 / 上传 -->
  <div class="modal" id="resultModal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-card">
      <h3 id="modalTitle">录音完成 ✅</h3>
      <div style="margin:10px 0">
        <label for="filenameInput" class="hint">请输入文件名(例如：jack_pre, jack_post)</label>
        <input type="text" id="filenameInput" placeholder="文件名" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:8px;font-size:14px;margin-top:4px" />
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="secondary" id="btnUpload">上传</button>
        <button id="btnDownload">下载</button>
      </div>
      <div id="uploadStatus" class="hint" style="margin-top:8px"></div>
    </div>
  </div>

<script>
(function(){
  // ===== Polyfill: 旧版浏览器的 getUserMedia 试探 =====
  (function ensureGetUserMedia(){
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => { console.log("麦克风采集成功", stream); })
        .catch(err => { console.error("麦克风采集失败:", err); });
    } else {
      console.error("该浏览器不支持麦克风采集");
    }
  })();

  const dpr = window.devicePixelRatio || 1;
  const jitterCanvas = document.getElementById('jitter');
  const spec = document.getElementById('spectrum');
  const toggleBtn = document.getElementById('toggle');
  const reenumBtn = document.getElementById('reenum');
  const micsSel = document.getElementById('mics');
  const smoothingInp = document.getElementById('smoothing');
  const gainInp = document.getElementById('gain');
  const smoothingVal = document.getElementById('smoothingVal');
  const gainVal = document.getElementById('gainVal');
  const scopeInp = document.getElementById('scope');
  const scopeVal = document.getElementById('scopeVal');
  const srEl = document.getElementById('sr');
  const peakEl = document.getElementById('peak'); // 复用为 jitter 显示
  const ctxState = document.getElementById('ctxState');
  const yearEl = document.getElementById('year');
  const supportHint = document.getElementById('supportHint');
  yearEl.textContent = new Date().getFullYear();

  // —— 弹窗元素 —— 
  const modal = document.getElementById('resultModal');
  const btnDownload = document.getElementById('btnDownload');
  const btnUpload = document.getElementById('btnUpload');
  const uploadStatus = document.getElementById('uploadStatus');
  const filenameInput = document.getElementById('filenameInput');

  // —— 录音器 & 音频节点 —— 
  let mediaRecorder = null;
  let lastRecording = null; // { blob, mime, filename }

  let ac = null, analyser = null, gainNode = null, src = null, stream = null, raf = null;

  // —— 频谱保留（峰值缓降，静音也保持顺滑）——
  let specHold = null; // Uint8Array

  // —— Jitter 状态 —— 
  let prevPeriodSec = null;             // 上一估计周期（秒）
  let jitterHistory = [];               // 历史（百分比值）
  const JITTER_HISTORY_LEN = 600;       // ~10s 轨迹（60FPS 近似）

  // —— 静音检测 & 连续绘制参数 ——
  function rms(arr){ let s=0; for(let i=0;i<arr.length;i++) s+=arr[i]*arr[i]; return Math.sqrt(s/arr.length); }
  const SILENCE_RMS = 0.01;      // 约 -40dB，按设备可调 0.005~0.02
  const JITTER_DECAY = 0.94;     // 静音时向 0% 衰减系数（0.9 更快，0.98 更慢）
  const JITTER_STEP  = 0.02;     // 每帧基础下拉（%）
  const JITTER_FLOOR_NOISE = 0.03; // 地板随机抖动上限（%）

  // 基础环境提示
  const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if (!isSecure) {
    supportHint.textContent = '⚠️ 非安全环境：请使用 HTTPS 或 localhost。';
  }

  function resizeCanvas(c){
    const rect = c.parentElement ? c.parentElement.getBoundingClientRect() : {width: c.clientWidth};
    const cssW = Math.floor(rect.width);
    const cssH = Math.max(160, Math.floor(cssW * 0.4));
    c.style.height = cssH + 'px';
    c.width  = Math.floor(cssW * dpr);
    c.height = Math.floor(cssH * dpr);
  }

  const onResize = ()=>{resizeCanvas(jitterCanvas); resizeCanvas(spec)};
  window.addEventListener('resize', onResize);
  onResize();

  async function enumerate(){
    if (!(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)) {
      micsSel.innerHTML = '<option value="">默认麦克风（设备切换不可用）</option>';
      return;
    }
    try{
      const tmp = await navigator.mediaDevices.getUserMedia({audio:true});
      tmp.getTracks().forEach(t=>t.stop());
      const list = await navigator.mediaDevices.enumerateDevices();
      const mics = list.filter(d=>d.kind==='audioinput');
      const opts = mics.map((d,i)=>`<option value="${d.deviceId||''}">${d.label||`麦克风 ${i+1}`}</option>`).join('');
      micsSel.innerHTML = opts || '<option value="">默认麦克风（未列出设备）</option>';
    }catch(e){
      micsSel.innerHTML='<option value="">默认麦克风</option>';
    }
  }
  enumerate();

  function getTimestamp() {
    const d = new Date();
    const pad = n => n.toString().padStart(2, '0');
    return [d.getFullYear(),pad(d.getMonth()+1),pad(d.getDate()),pad(d.getHours()),pad(d.getMinutes()),pad(d.getSeconds())].join('_');
  }

  async function start(){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert('当前浏览器不支持或未启用麦克风采集（缺少 navigator.mediaDevices.getUserMedia）。请升级系统/浏览器，或改用 Safari/系统浏览器。');
      return;
    }

    toggleBtn.disabled = true;
    try{
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) { throw new Error('此浏览器不支持 Web Audio API（缺少 AudioContext）。'); }

      ac = new AudioCtx();
      if(ac.state==='suspended') await ac.resume();
      ctxState.textContent=ac.state;
      ac.onstatechange = (e) => { if (ctxState && e && e.target) ctxState.textContent = e.target.state; };

      const baseConstraints = { audio: { echoCancellation:true, noiseSuppression:true, autoGainControl:false } };
      let constraints = baseConstraints;
      const canSelectDevice = !!(micsSel && micsSel.value && micsSel.value !== '');
      if (canSelectDevice) {
        constraints = { audio: { deviceId: { exact: micsSel.value }, echoCancellation:true, noiseSuppression:true, autoGainControl:false } };
      }

      try { stream = await navigator.mediaDevices.getUserMedia(constraints); }
      catch (err) { stream = await navigator.mediaDevices.getUserMedia({ audio: true }); }

      src = ac.createMediaStreamSource(stream);
      analyser = ac.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = parseFloat(smoothingInp.value);

      gainNode = ac.createGain();
      gainNode.gain.value = parseFloat(gainInp.value);

      src.connect(gainNode).connect(analyser);

      srEl.textContent = '采样率: ' + ac.sampleRate + ' Hz';

      // 初始化 Jitter & 频谱缓降
      prevPeriodSec = null;
      jitterHistory = [];
      peakEl.textContent = 'jitter_local_percent: —';
      specHold = new Uint8Array(analyser.frequencyBinCount);

      // 开始绘制
      raf = requestAnimationFrame(draw);
      toggleBtn.textContent = '停止';

      // 录音能力
      if ('MediaRecorder' in window) {
        let chunks = [];
        try{
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' }, { bitsPerSecond: 128000 });
          chunks = [];
          mediaRecorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };
          mediaRecorder.onstop = () => {
            if (!chunks.length) { showModal(); return; }
            const mime = mediaRecorder.mimeType || 'audio/webm';
            const blob = new Blob(chunks, {type: mime});
            const ts = new Date().toISOString().replace(/[:.]/g,'-');
            const filename = `record-${ts}.${mime.includes('webm') ? 'webm' : mime.split('/')[1] || 'dat'}`;
            lastRecording = { blob, mime, filename };
            showModal();
          };
          mediaRecorder.start();
        }catch(err){ alert('录音启动失败：' + (err.message || err)); }
      } else {
        console.log('当前环境不支持 MediaRecorder（iOS 老版本常见）');
      }

    }catch(e){
      alert((e && e.message) ? e.message : '启动失败，可能是未授权麦克风、非 HTTPS、或浏览器不兼容。');
      stop();
    }finally{
      toggleBtn.disabled = false;
    }
  }

  async function stop(){
    cancelAnimationFrame(raf); raf = null;
    try{ if (gainNode) gainNode.disconnect(); }catch(_){ }
    try{ if (analyser) analyser.disconnect(); }catch(_){ }
    try{ if (src) src.disconnect(); }catch(_){ }
    try{ if (stream){ stream.getTracks().forEach(t=>t.stop()); } }catch(_){ }
    try{ if (ac){ ac.onstatechange = null; await ac.close(); } }catch(_){ }

    ac = null; analyser = null; gainNode = null; src = null; stream = null;

    ctxState.textContent='';
    toggleBtn.textContent='开始';

    // 停止录音：触发 MediaRecorder.onstop，从而弹出操作弹窗
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    } else {
      showModal();
    }

    // 重置显示
    prevPeriodSec = null;
    jitterHistory = [];
    peakEl.textContent = 'jitter_local_percent: —';
  }

  // —— 弹窗逻辑 —— 
  function showModal(){
    modal.setAttribute('aria-hidden','false');
    uploadStatus.textContent = '';
    btnDownload.disabled = !lastRecording;
  }
  function hideModal(){ modal.setAttribute('aria-hidden','true'); }

  // 下载当前录音
  btnDownload.addEventListener('click', () => {
    if (!lastRecording) { alert('没有可下载的录音。'); return; }
    if (!filenameInput.value.trim()) { alert('请输入文件名。'); return; }
    const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.webm`;

    const { blob } = lastRecording;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url; a.download = input_filename;
    document.body.appendChild(a); a.click(); a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  // 上传当前录音（请替换为你的上传接口）
  btnUpload.addEventListener('click', async () => {
    try{
      if (!lastRecording) { alert('没有可上传的录音。'); return; }
      if (!filenameInput.value.trim()) { alert('请输入文件名。'); return; }
      const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.webm`;

      uploadStatus.textContent = '正在上传…';
      const ENDPOINT = 'https://43.136.55.43/api/upload';
      const { blob, mime } = lastRecording;
      const fd = new FormData();
      fd.append('file', blob, input_filename);
      fd.append('mime', mime);
      const res = await fetch(ENDPOINT, { method:'POST', body: fd });
      if (!res.ok) throw new Error('上传失败，状态码：' + res.status);
      const text = await res.text().catch(()=> '');
      console.log('上传响应:', text);
      uploadStatus.textContent = '上传成功！';
    }catch(err){
      uploadStatus.textContent = '上传失败：' + (err && err.message ? err.message : err);
    }
  });

  modal.addEventListener('click', (e)=>{ if(e.target===modal) hideModal(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideModal(); });

  toggleBtn.addEventListener('click',()=>{ if(ac) stop(); else start(); });
  reenumBtn.addEventListener('click',enumerate);

  smoothingInp.addEventListener('input',()=>{
    const v = parseFloat(smoothingInp.value);
    smoothingVal.textContent = v.toFixed(2);
    if(analyser) analyser.smoothingTimeConstant = v;
  });
  gainInp.addEventListener('input',()=>{
    const v = parseFloat(gainInp.value);
    gainVal.textContent = v.toFixed(1);
    if(gainNode) gainNode.gain.value = v;
  });
  scopeInp && scopeInp.addEventListener('input', () => {
    const v = parseFloat(scopeInp.value);
    scopeVal.textContent = v.toFixed(2) + '%';
  });

  // ====== 实时 Jitter 计算与绘制（连续模式）======

  function hannWindow(arr){
    const N = arr.length;
    for (let i=0;i<N;i++){
      arr[i] *= 0.5 * (1 - Math.cos(2*Math.PI*i/(N-1)));
    }
  }

  // 估计单帧基频周期（秒）；返回 null 表示无效
  function estimatePeriodSec(frame, sr, fmin=60, fmax=400){
    // 去直流
    let mean = 0; for (let i=0;i<frame.length;i++) mean += frame[i]; mean /= frame.length;
    for (let i=0;i<frame.length;i++) frame[i] -= mean;

    // 归一化
    let maxAbs = 1e-12;
    for (let i=0;i<frame.length;i++){ const a = Math.abs(frame[i]); if (a>maxAbs) maxAbs = a; }
    if (maxAbs < 1e-6) return null;
    for (let i=0;i<frame.length;i++) frame[i] /= maxAbs;

    // 中心裁剪（抑制小幅噪声的假峰）
    const clip = 0.2; // 0~1，越大越“硬”
    for (let i=0;i<frame.length;i++){
      const x = frame[i];
      frame[i] = Math.abs(x) < clip ? 0 : (x > 0 ? x-clip : x+clip);
    }

    // 加窗
    hannWindow(frame);

    // 直接自相关（N^2），2048 点开销可接受
    const N = frame.length;
    const acf = new Float32Array(N);
    for (let lag=0; lag<N; lag++){
      let s = 0; for (let i=0; i<N-lag; i++) s += frame[i]*frame[i+lag];
      acf[lag] = s;
    }

    // 在 [lagMin, lagMax] 搜峰
    const lagMin = Math.floor(sr / fmax);
    const lagMax = Math.min(N-1, Math.ceil(sr / fmin));
    if (lagMax - lagMin < 4) return null;

    let bestLag = -1, bestVal = -Infinity;
    for (let lag=lagMin; lag<=lagMax; lag++){
      const v = acf[lag];
      if (v > bestVal){ bestVal = v; bestLag = lag; }
    }
    if (bestLag <= 0) return null;

    // 抛物线插值细化
    const l = bestLag-1, r = bestLag+1;
    if (l>=0 && r<N){
      const yl = acf[l], y0 = acf[bestLag], yr = acf[r];
      const denom = (yl - 2*y0 + yr);
      if (Math.abs(denom) > 1e-9){
        const delta = 0.5 * (yl - yr) / denom;
        bestLag = bestLag + delta; // 允许小数滞后
      }
    }
    const periodSec = bestLag / sr;
    if (periodSec < 1/fmax || periodSec > 1/fmin) return null;
    return periodSec;
  }

  // Praat 本地抖动近似：|T_i - T_{i-1}| / mean(T_i, T_{i-1})
  function computeLocalJitterPercent(currT, prevT, maxPeriodFactor=1.3){
    if (prevT == null) return null;
    const meanT = 0.5 * (currT + prevT);
    if (meanT <= 0) return null;
    const ratio = currT > prevT ? (currT/prevT) : (prevT/currT);
    if (ratio > maxPeriodFactor) return null; // 排除过大跳变
    const frac = Math.abs(currT - prevT) / meanT;
    return frac * 100.0;
  }

  function draw(){
    if (!analyser || !ac){ raf = requestAnimationFrame(draw); return; }

    const sctx = spec.getContext('2d');
    const jctx = jitterCanvas.getContext('2d');
    const SW = spec.width, SH = spec.height;
    const JW = jitterCanvas.width, JH = jitterCanvas.height;

    // ===== 1) 从 analyser 抽样一帧 PCM，估计能量 =====
    const td = new Float32Array(analyser.fftSize);
    analyser.getFloatTimeDomainData(td);
    const level = rms(td);
    const isSilent = level < SILENCE_RMS;

    // ===== 2) 频谱（峰值缓降） =====
    const fd = new Uint8Array(analyser.frequencyBinCount);
    analyser.getByteFrequencyData(fd);
    if (!specHold || specHold.length !== fd.length) specHold = new Uint8Array(fd.length);
    // 缓降：保持上一帧更大值，向下按 0.96 衰减
    for (let i=0;i<fd.length;i++){
      const decayed = Math.floor(specHold[i] * 0.96);
      specHold[i] = Math.max(fd[i], decayed);
    }
    sctx.clearRect(0,0,SW,SH);
    sctx.fillStyle = '#ffffff'; sctx.fillRect(0,0,SW,SH);
    const bw = Math.max(1, Math.floor(SW / specHold.length));
    sctx.fillStyle = '#06b6d4';
    for (let i = 0; i < specHold.length; i++) {
      const v = specHold[i] / 255;
      const h = v * SH;
      sctx.fillRect(i * bw, SH - h, bw - 1, h);
    }

    // ===== 3) Jitter 连续曲线：有声估计 / 静音平滑滑行 =====
    let currJ = null;
    if (!isSilent){
      const currPeriodSec = estimatePeriodSec(td.slice(), ac.sampleRate, 60, 400);
      if (currPeriodSec != null){
        const j = computeLocalJitterPercent(currPeriodSec, prevPeriodSec, 1.3);
        if (j != null){
          jitterHistory.push(j);
          if (jitterHistory.length > JITTER_HISTORY_LEN) jitterHistory.shift();
          currJ = j;
        }
        prevPeriodSec = currPeriodSec;
      }
    } else {
      // 静音：不做周期估计；曲线向 0% 缓慢回落并维持轻微抖动
      prevPeriodSec = null;
      let last = jitterHistory.length ? jitterHistory[jitterHistory.length-1] : 0;
      let next = Math.max(0, last * JITTER_DECAY - JITTER_STEP);
      next += Math.random() * JITTER_FLOOR_NOISE; // 0~0.03% 细微抖动
      jitterHistory.push(next);
      if (jitterHistory.length > JITTER_HISTORY_LEN) jitterHistory.shift();
    }

    // 画 Jitter 背景网格
    jctx.clearRect(0,0,JW,JH);
    jctx.fillStyle = '#ffffff'; jctx.fillRect(0,0,JW,JH);
    const maxView = parseFloat(scopeInp ? scopeInp.value : 10);
    jctx.strokeStyle = '#cbd5e1';
    jctx.lineWidth = Math.max(1, dpr);
    const refPerc = [0, 1, 2, 5, 10].filter(p=>p<=maxView);
    refPerc.forEach(p=>{
      const y = JH - (p/maxView) * JH;
      if (y>=0 && y<=JH){ jctx.beginPath(); jctx.moveTo(0, y); jctx.lineTo(JW, y); jctx.stroke(); }
    });

    // 画 Jitter 曲线
    if (jitterHistory.length > 1){
      jctx.beginPath();
      jctx.strokeStyle = '#2563eb';
      const n = jitterHistory.length;
      for (let i=0;i<n;i++){
        const x = Math.round((i/(n-1)) * (JW-1));
        const val = Math.min(jitterHistory[i], maxView);
        const y = Math.round(JH - (val/maxView) * (JH-1));
        if (i===0) jctx.moveTo(x,y); else jctx.lineTo(x,y);
      }
      jctx.stroke();
    }

    // 数值显示
    if (!isSilent && currJ != null){
      peakEl.textContent = 'jitter_local_percent: ' + currJ.toFixed(2) + '%';
    } else if (isSilent){
      const val = jitterHistory.length ? jitterHistory.at(-1) : 0;
      peakEl.textContent = 'jitter_local_percent: ~' + val.toFixed(2) + '%（静音）';
    } else {
      if (!jitterHistory.length) peakEl.textContent = 'jitter_local_percent: —';
    }

    raf = requestAnimationFrame(draw);
  }

})();
</script>
</body>
</html>
