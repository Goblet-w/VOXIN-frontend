<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VOXIN · 浅色版</title>
  <style>
    :root{
      --bg:#ffffff;          /* 页面背景 */
      --card:#f8fafc;        /* 卡片背景 */
      --soft:#e5e7eb;        /* 柔和分隔线 */
      --text:#0f172a;        /* 主文字 */
      --muted:#475569;       /* 次级文字 */
      --accent:#2563eb;      /* 主按钮/高亮 */
      --accent2:#06b6d4;     /* 频谱色（已用于圆环右侧） */
      --danger:#ef4444;      /* 危险色 */
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:8px 0 6px}
    .sub{color:var(--muted);font-size:13px}
    .card{background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 2px 14px rgba(15,23,42,.06);padding:12px;overflow: hidden;}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button,select,input[type=range]{appearance:none;border:none}
    button{padding:10px 14px;border-radius:12px;color:#fff;background:var(--accent);font-weight:600;cursor:pointer}
    button.secondary{background:#e2e8f0;color:#0f172a}
    button.danger{background:var(--danger);color:#fff}
    button.ghost{background:transparent;color:var(--muted);border:1px solid var(--soft)}
    button:disabled{opacity:.6}
    select{padding:10px;border-radius:10px;background:#f1f5f9;color:#0f172a;border:1px solid var(--soft)}
    label{font-size:13px;color:var(--muted)}
    .slider{width:100%}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    .hint{font-size:12px;color:#64748b}
    .pill{display:inline-block;font-size:12px;padding:4px 8px;border-radius:999px;background:#eef2f7;border:1px solid #d1d5db;color:#0f172a}
    canvas{display:block;width:100%;height:200px;border-radius:12px;background:#f1f5f9;border:1px solid var(--soft)}
    .badge{font-size:12px;color:#334155}
    .footer{font-size:12px;color:#64748b;text-align:center;margin-top:16px}
    @media (min-width:720px){canvas#wave{height:260px}}

    /* 焦点可见性 */
    button:focus,select:focus,input:focus{outline:3px solid rgba(37,99,235,.35);outline-offset:2px}

    /* —— 弹窗 —— */
    .modal{position:fixed;inset:0;background:rgba(15,23,42,.45);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
    .modal[aria-hidden="false"]{display:flex}
    .modal-card{width:100%;max-width:460px;background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,.2);padding:16px}
    .modal-card h3{margin:4px 0 6px;font-size:18px}
    .modal-card p{margin:0 0 10px;color:var(--muted)}

    .ring-wrap{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr)); /* 始终两列 */
      gap:8px;
      align-items:stretch;
    }

    .ring{
      display:flex;
      align-items:center;
      justify-content:center;
      background:#f1f5f9;
      border:1px solid var(--soft);
      border-radius:12px;

      aspect-ratio: 1 / 1;  /* 正方形，避免椭圆 */
      width:100%;           /* 跟随网格等分 */
      /* 不要固定/最小高度，交给 aspect-ratio 和宽度决定 */
    }

    /* 重要：不要用 100%/100% 拉伸 canvas，交给 JS 来设尺寸 */
    .ring canvas{
      background:transparent;
      border:none;
      border-radius:12px;
      width:auto;
      height:auto;
      display:block;
    }


  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>VOXIN - 开启你的声音训练之旅吧！🎤✨🚀</h1>
      <div class="sub">
        <span id="supportHint" class="hint" style="display:block;margin-top:4px"></span>
      </div>
    </header>

    <section class="card" id="displayCard">
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <span class="badge" id="sr">采样率: —</span>
        <span class="pill" id="peak">峰值: 0%</span>
      </div>
      <canvas id="wave"></canvas>

      <!-- ▼▼▼ 替换掉原先的 spectrum：双圆环 ▼▼▼ -->
      <div class="ring-wrap" style="margin-top:12px">
        <div class="ring"><canvas id="ringJitter" aria-label="jitter_local_percent"></canvas></div>
        <div class="ring"><canvas id="ringShimmer" aria-label="shimmer_local_percent"></canvas></div>
      </div>
      <!-- ▲▲▲ 替换结束 ▲▲▲ -->
    </section>

    <section class="grid" style="margin-top:12px">
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button id="toggle">开始</button>
            <button class="secondary" id="reenum">刷新设备</button>
          </div>
          <div class="badge" id="ctxState"></div>
        </div>

        <div style="height:8px"></div>
        <div class="row">
          <label for="mics">麦克风</label>
          <select id="mics"></select>
        </div>

        <div class="row" style="gap:16px;margin-top:8px">
          <div style="flex:1;min-width:140px">
            <label>平滑 (smoothing) <span id="smoothingVal" class="badge">0.50</span></label>
            <input class="slider" id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.5" />
          </div>
          <div style="flex:1;min-width:140px">
            <label>增益 (gain) <span id="gainVal" class="badge">1.0</span></label>
            <input class="slider" id="gain" type="range" min="0.1" max="3" step="0.1" value="1" />
          </div>
          <div style="flex:1;min-width:140px">
            <label>波形缩放 (scope) <span id="scopeVal" class="badge">1.00×</span></label>
            <input class="slider" id="scope" type="range" min="0.25" max="100" step="0.25" value="50" />
          </div>
        </div>
      </div>
    </section>

    <div class="footer">© <span id="year"></span> VOXIN Demo</div>
  </div>

  <!-- 结果弹窗：下载 / 上传 -->
  <div class="modal" id="resultModal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-card">
      <h3 id="modalTitle">录音完成 ✅</h3>
      <div style="margin:10px 0">
        <label for="filenameInput" class="hint">请输入文件名(例如：jack_pre, jack_post)</label>
        <input type="text" id="filenameInput" placeholder="文件名" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:8px;font-size:14px;margin-top:4px" />
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="secondary" id="btnUpload">上传</button>
        <button id="btnDownload">下载</button>
      </div>
      <div id="uploadStatus" class="hint" style="margin-top:8px"></div>
    </div>
  </div>

<script>
(function(){
  // ===== Polyfill: 旧版浏览器的 getUserMedia =====
  (function ensureGetUserMedia(){
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => { console.log("麦克风采集成功", stream); })
        .catch(err => { console.error("麦克风采集失败:", err); });
    } else {
      console.error("该浏览器不支持麦克风采集");
    }
  })();

  const dpr = window.devicePixelRatio || 1;
  const wave = document.getElementById('wave');
  const ringJitter = document.getElementById('ringJitter');
  const ringShimmer = document.getElementById('ringShimmer');
  const toggleBtn = document.getElementById('toggle');
  const reenumBtn = document.getElementById('reenum');
  const micsSel = document.getElementById('mics');
  const smoothingInp = document.getElementById('smoothing');
  const gainInp = document.getElementById('gain');
  const smoothingVal = document.getElementById('smoothingVal');
  const gainVal = document.getElementById('gainVal');
  const scopeInp = document.getElementById('scope');
  const scopeVal = document.getElementById('scopeVal');
  const srEl = document.getElementById('sr');
  const peakEl = document.getElementById('peak');
  const ctxState = document.getElementById('ctxState');
  const yearEl = document.getElementById('year');
  const supportHint = document.getElementById('supportHint');
  yearEl.textContent = new Date().getFullYear();

  // —— 弹窗元素 —— 
  const modal = document.getElementById('resultModal');
  const btnDownload = document.getElementById('btnDownload');
  const btnUpload = document.getElementById('btnUpload');
  const uploadStatus = document.getElementById('uploadStatus');
  const filenameInput = document.getElementById('filenameInput');

  // —— 录音器 —— 
  let mediaRecorder = null;
  let lastRecording = null; // { blob, mime, filename }

  let ac = null, analyser = null, gainNode = null, src = null, stream = null, raf = null;

  // —— 环形缓冲（历史波形），默认 30 秒 —— 
  let windowSec = 30;
  let ring = null, ringLen = 0, writeIdx = 0, totalWritten = 0, tdFloat = null;

  // —— 圆环状态 —— 
  const state = {
    jitterPercent: 0,   // 0-?
    shimmerPercent: 0,  // 0-?
    ewmaJ: 0,
    ewmaS: 0
  };

  // 基础环境提示
  const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if (!isSecure) {
    supportHint.textContent = '⚠️ 非安全环境：请使用 HTTPS 或 localhost。';
  }

  function resizeCanvas(c){
    const rect = c.parentElement ? c.parentElement.getBoundingClientRect() : {width: c.clientWidth};
    const cssW = Math.floor(rect.width);
    const cssH = Math.max(160, Math.floor(cssW * 0.4));
    if (c === wave) {
      c.style.height = cssH + 'px';
    }
    c.width  = Math.floor((c === wave ? cssW : Math.min(cssW, 360)) * dpr);
    c.height = Math.floor((c === wave ? Math.max(160, Math.floor(cssW * 0.4)) : Math.min(c.parentElement.clientHeight, 420)) * dpr);
  }

  function resizeRing(c){
    const rect = c.parentElement.getBoundingClientRect();
    // 若高度未定，用宽度兜底（aspect-ratio 会让最终高度≈宽度）
    let sizeCss = Math.floor(rect.width);
    if (rect.height && rect.height > 0) {
      sizeCss = Math.floor(Math.min(rect.width, rect.height));
    }

    // 展示尺寸（CSS 像素）
    c.style.width  = sizeCss + 'px';
    c.style.height = sizeCss + 'px';

    // 绘图像素（物理像素）
    const dpr = window.devicePixelRatio || 1;
    c.width  = Math.floor(sizeCss * dpr);
    c.height = Math.floor(sizeCss * dpr);
  }



  const onResize = ()=>{
    resizeCanvas(wave);
    resizeRing(ringJitter);
    resizeRing(ringShimmer);
  };
  window.addEventListener('resize', onResize);
  onResize();

  async function enumerate(){
    if (!(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)) {
      micsSel.innerHTML = '<option value="">默认麦克风（设备切换不可用）</option>';
      return;
    }
    try{
      const tmp = await navigator.mediaDevices.getUserMedia({audio:true});
      tmp.getTracks().forEach(t=>t.stop());
      const list = await navigator.mediaDevices.enumerateDevices();
      const mics = list.filter(d=>d.kind==='audioinput');
      const opts = mics.map((d,i)=>`<option value="${d.deviceId||''}">${d.label||`麦克风 ${i+1}`}</option>`).join('');
      micsSel.innerHTML = opts || '<option value="">默认麦克风（未列出设备）</option>';
    }catch(e){
      micsSel.innerHTML='<option value="">默认麦克风</option>';
    }
  }
  enumerate();

  function getTimestamp() {
    const d = new Date();
    const pad = n => n.toString().padStart(2, '0');
    return [
      d.getFullYear(),
      pad(d.getMonth() + 1),
      pad(d.getDate()),
      pad(d.getHours()),
      pad(d.getMinutes()),
      pad(d.getSeconds())
    ].join('_');
  }

  // ===== 估计 Jitter/Shimmer（基于最近1秒，简化法） =====
  function estimateMetrics(rbuf, writeIdx, sr){
    const secs = 1.0;
    const N = Math.min(rbuf.length, Math.floor(sr * secs));
    if (N < 1024) return { jitterP: 0, shimmerP: 0, ok:false };

    // 拷贝最近 N 个样本并算 RMS
    const buf = new Float32Array(N);
    let start = (writeIdx - N + rbuf.length) % rbuf.length;
    let rms2 = 0;
    for (let i = 0; i < N; i++){
      const v = rbuf[(start + i) % rbuf.length];
      buf[i] = v; rms2 += v*v;
    }
    const rms = Math.sqrt(rms2 / N);

    // 能量门限：把原来的 1e-4 改成更宽松（典型人声 rms ~ 0.02~0.2）
    if (rms < 0.002) return { jitterP: 0, shimmerP: 0, ok:false };

    // —— 自适应舒密特过零 —— //
    // 阈值随 RMS 走：说话小声也能触发；大声不会误检太多
    const thr    = Math.max(0.003, rms * 0.6);
    const relThr = thr * 0.35;

    let above = false;
    let zc = [];
    for (let i = 1; i < N; i++){
      if (!above && buf[i-1] < -relThr && buf[i] >=  thr) { above = true;  zc.push(i); }
      if ( above && buf[i]    <  relThr)                    { above = false; }
    }

    // 回退策略：如果自适应舒密特太严格，就退回普通过零
    if (zc.length < 4){
      zc = [];
      for (let i = 1; i < N; i++){
        if (buf[i-1] < 0 && buf[i] >= 0) zc.push(i);
      }
    }
    if (zc.length < 6) return { jitterP: 0, shimmerP: 0, ok:false };

    // 允许更宽的基音范围（50–500 Hz），增强鲁棒性
    const minSamp = Math.floor(sr / 500);
    const maxSamp = Math.ceil (sr / 50);

    const periods = [];
    const amps = [];

    for (let k = 1; k < zc.length; k++){
      const a = zc[k-1], b = zc[k];
      const L = b - a;
      if (L < minSamp || L > maxSamp) continue;

      periods.push(L);

      // 周期振幅（峰-峰），避免 0
      let maxV = -1e9, minV = 1e9;
      for (let i = a; i < b; i++){ const v = buf[i]; if (v > maxV) maxV = v; if (v < minV) minV = v; }
      amps.push(Math.max(1e-9, maxV - minV));
    }

    if (periods.length < 4) return { jitterP: 0, shimmerP: 0, ok:false };

    const mean = arr => arr.reduce((s,v)=>s+v,0)/arr.length;
    const mP = mean(periods);
    const mA = mean(amps);

    // Praat 风格：相邻差的平均 / 均值
    let sumDP = 0, sumDA = 0;
    for (let i = 1; i < periods.length; i++) sumDP += Math.abs(periods[i] - periods[i-1]);
    for (let i = 1; i < amps.length;    i++) sumDA += Math.abs(amps[i]    - amps[i-1]);

    const jLocal = (sumDP / (periods.length - 1)) / mP;
    const sLocal = (sumDA / (amps.length    - 1)) / mA;

    return {
      jitterP: Math.max(0, Math.min(50, jLocal * 100)),
      shimmerP: Math.max(0, Math.min(50, sLocal * 100)),
      ok: true
    };
  }



  // ===== 圆环绘制 =====
  function drawRing(canvas, value, label, color){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;
    const r = Math.min(W, H) * 0.36;
    const lw = Math.max(8, Math.round(r*0.22));

    ctx.clearRect(0,0,W,H);

    // 背景环
    ctx.lineCap = 'round';
    ctx.lineWidth = lw;
    ctx.strokeStyle = '#e2e8f0';
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI*0.75, Math.PI*0.75);
    ctx.stroke();

    // 数值环（0~30%映射到 270°）
    const maxP = 50; // 经验上限，避免一发散就铺满
    const ratio = Math.max(0, Math.min(1, value / maxP));
    const start = -Math.PI*0.75;
    const end = start + ratio * (Math.PI*1.5);

    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.arc(cx, cy, r, start, end);
    ctx.stroke();

    // 中心文字
    ctx.fillStyle = '#0f172a';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    // 数字
    const valStr = value.toFixed(2) + '%';
    ctx.font = Math.round(r*0.4) + 'px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(valStr, cx, cy - r*0.05);

    // 标签
    ctx.fillStyle = '#475569';
    ctx.font = Math.round(r*0.2) + 'px system-ui, -apple-system, Segoe UI, Roboto';
    ctx.fillText(label, cx, cy + r*0.6);
  }

  async function start(){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert('当前浏览器不支持或未启用麦克风采集（缺少 navigator.mediaDevices.getUserMedia）。请升级系统/浏览器，或改用 Safari/系统浏览器。');
      return;
    }

    toggleBtn.disabled = true;
    try{
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        throw new Error('此浏览器不支持 Web Audio API（缺少 AudioContext）。');
      }

      ac = new AudioCtx();
      if(ac.state==='suspended') await ac.resume();
      ctxState.textContent=ac.state;
      ac.onstatechange = (e) => {
        if (ctxState && e && e.target) ctxState.textContent = e.target.state;
      };

      const baseConstraints = { audio: true };
      let constraints = baseConstraints;

      const canSelectDevice = !!(micsSel && micsSel.value && micsSel.value !== '');
      if (canSelectDevice) {
        constraints = {
          audio: {
            deviceId: { exact: micsSel.value },
            echoCancellation:false, noiseSuppression:false, autoGainControl:false
          }
        };
      } else {
        constraints = { audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false } };
      }

      try { stream = await navigator.mediaDevices.getUserMedia(constraints); }
      catch (err) { stream = await navigator.mediaDevices.getUserMedia(baseConstraints); }

      src = ac.createMediaStreamSource(stream);
      analyser = ac.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = parseFloat(smoothingInp.value);

      gainNode = ac.createGain();
      gainNode.gain.value = parseFloat(gainInp.value);

      src.connect(gainNode).connect(analyser);

      srEl.textContent = '采样率: ' + ac.sampleRate + ' Hz';

      // 初始化环形缓冲
      ringLen = Math.ceil(ac.sampleRate * windowSec * 1.2);
      ring = new Float32Array(ringLen);
      writeIdx = 0; totalWritten = 0;
      tdFloat = new Float32Array(analyser.fftSize);
      const fd = new Uint8Array(analyser.frequencyBinCount); // 仍用于峰值粗估

      function draw(){
        const wctx = wave.getContext('2d');
        const W = wave.width, H = wave.height;

        // 线宽跟随 DPR
        wctx.lineWidth = Math.max(1, dpr);

        // 背景与中线（浅色）
        wctx.clearRect(0,0,W,H);
        wctx.fillStyle = '#ffffff'; wctx.fillRect(0,0,W,H);
        wctx.strokeStyle = '#cbd5e1'; wctx.beginPath(); wctx.moveTo(0,H/2); wctx.lineTo(W,H/2); wctx.stroke();

        // 收集一帧
        analyser.getFloatTimeDomainData(tdFloat);
        let pk = 0;
        for (let i = 0; i < tdFloat.length; i++) {
          const v = tdFloat[i];
          ring[writeIdx] = v;
          writeIdx = (writeIdx + 1) % ringLen;
          totalWritten++;
          if (Math.abs(v) > pk) pk = Math.abs(v);
        }
        peakEl.textContent = '峰值: ' + Math.min(100, Math.round(pk * 100)) + '%';

        // 固定目标窗口
        const targetSamples = Math.floor(ac.sampleRate * windowSec);
        const available = Math.min(totalWritten, targetSamples);
        const stride = Math.max(1, Math.floor(targetSamples / W));
        let startIdx = (writeIdx - available + ringLen) % ringLen;
        const visibleCols = Math.max(1, Math.floor(available / stride));
        const offsetX = W - visibleCols;
        const scope = scopeInp ? parseFloat(scopeInp.value) : 1;

        // 波形（竖条）
        wctx.strokeStyle = '#2563eb';
        wctx.beginPath();
        for (let x = offsetX; x < W; x++) {
          let min =  1, max = -1;
          for (let k = 0; k < stride; k++) {
            const idx = (startIdx + (x - offsetX) * stride + k) % ringLen;
            let v = ring[idx] * scope;
            if (v >  1) v =  1;
            if (v < -1) v = -1;
            if (v < min) min = v;
            if (v > max) max = v;
          }
          const y1 = (1 - (max + 1) / 2) * H;
          const y2 = (1 - (min + 1) / 2) * H;
          wctx.moveTo(x, y1);
          wctx.lineTo(x, y2);
        }
        wctx.stroke();

        // === 估计 Jitter & Shimmer，并绘制两个圆环 ===
        const { jitterP, shimmerP, ok } = estimateMetrics(ring, writeIdx, ac.sampleRate);
        // 简单平滑（EWMA）避免跳动
        const alpha = 0.8;
        if (ok){
          state.ewmaJ = alpha * jitterP + (1-alpha) * (state.ewmaJ || jitterP);
          state.ewmaS = alpha * shimmerP + (1-alpha) * (state.ewmaS || shimmerP);
          state.jitterPercent = state.ewmaJ;
          state.shimmerPercent = state.ewmaS;
        }

        // 画圆环
        drawRing(ringJitter, state.jitterPercent || 0, 'Jitter', '#2563eb');
        drawRing(ringShimmer, state.shimmerPercent || 0, 'Shimmer', '#06b6d4');

        raf = requestAnimationFrame(draw);
      }

      raf = requestAnimationFrame(draw);
      toggleBtn.textContent = '停止';

      // 录音能力
      if ('MediaRecorder' in window) {
        let chunks = [];
        try{
          mediaRecorder = new MediaRecorder(stream, { mimeType: 'audio/webm' }, { bitsPerSecond: 128000 });
          chunks = [];
          mediaRecorder.ondataavailable = e => { if(e.data.size>0) chunks.push(e.data); };
          mediaRecorder.onstop = () => {
            if (!chunks.length) {
              showModal();
              return;
            }
            const mime = mediaRecorder.mimeType || 'audio/webm';
            const blob = new Blob(chunks, {type: mime});
            const ts = new Date().toISOString().replace(/[:.]/g,'-');
            const filename = `record-${ts}.${mime.includes('webm') ? 'webm' : mime.split('/')[1] || 'dat'}`;
            lastRecording = { blob, mime, filename };
            showModal();
          };
          mediaRecorder.start();
        }catch(err){ alert('录音启动失败：' + (err.message || err)); }
      } else {
        console.log('当前环境不支持 MediaRecorder（iOS 老版本常见）');
      }

    }catch(e){
      alert((e && e.message) ? e.message :
            '启动失败，可能是未授权麦克风、非 HTTPS、或浏览器不兼容。');
      stop();
    }finally{
      toggleBtn.disabled = false;
    }
  }

  async function stop(){
    cancelAnimationFrame(raf); raf = null;
    try{ if (gainNode) gainNode.disconnect(); }catch(_){}
    try{ if (analyser) analyser.disconnect(); }catch(_){}
    try{ if (src) src.disconnect(); }catch(_){}
    try{ if (stream){ stream.getTracks().forEach(t=>t.stop()); } }catch(_){}
    try{
      if (ac){
        ac.onstatechange = null;
        await ac.close();
      }
    }catch(_){}

    ac = null; analyser = null; gainNode = null; src = null; stream = null;

    ctxState.textContent='';
    toggleBtn.textContent='开始';
    if (mediaRecorder && mediaRecorder.state !== 'inactive') {
      mediaRecorder.stop();
    } else {
      showModal();
    }
  }

  // —— 弹窗逻辑 —— 
  function showModal(){
    modal.setAttribute('aria-hidden','false');
    uploadStatus.textContent = '';
    btnDownload.disabled = !lastRecording;
  }
  function hideModal(){ modal.setAttribute('aria-hidden','true'); }

  // 下载当前录音
  btnDownload.addEventListener('click', () => {
    if (!lastRecording) { alert('没有可下载的录音。'); return; }
    if (!filenameInput.value.trim()) { alert('请输入文件名。'); return; }
    const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.webm`;

    const { blob } = lastRecording;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = input_filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  // 上传当前录音（请替换为你的上传接口）
  btnUpload.addEventListener('click', async () => {
    try{
      if (!lastRecording) { alert('没有可上传的录音。'); return; }
      if (!filenameInput.value.trim()) { alert('请输入文件名。'); return; }
      const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.webm`;

      uploadStatus.textContent = '正在上传…';
      const ENDPOINT = 'https://43.136.55.43/api/upload';
      const { blob, mime } = lastRecording;
      const fd = new FormData();
      fd.append('file', blob, input_filename);
      fd.append('mime', mime);
      const res = await fetch(ENDPOINT, { method:'POST', body: fd });
      if (!res.ok) throw new Error('上传失败，状态码：' + res.status);
      const text = await res.text().catch(()=> '');
      console.log('上传响应:', text);
      uploadStatus.textContent = '上传成功！';
    }catch(err){
      uploadStatus.textContent = '上传失败：' + (err && err.message ? err.message : err);
    }
  });

  modal.addEventListener('click', (e)=>{ if(e.target===modal) hideModal(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideModal(); });

  toggleBtn.addEventListener('click',()=>{ if(ac) stop(); else start(); });
  reenumBtn.addEventListener('click',enumerate);

  smoothingInp.addEventListener('input',()=>{
    const v = parseFloat(smoothingInp.value);
    smoothingVal.textContent = v.toFixed(2);
    if(analyser) analyser.smoothingTimeConstant = v;
  });
  gainInp.addEventListener('input',()=>{
    const v = parseFloat(gainInp.value);
    gainVal.textContent = v.toFixed(1);
    if(gainNode) gainNode.gain.value = v;
  });
  scopeInp && scopeInp.addEventListener('input', () => {
    const v = parseFloat(scopeInp.value);
    scopeVal.textContent = v.toFixed(2) + '×';
  });
})();
</script>
</body>
</html>
