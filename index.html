<!doctype html>
<html lang="zh-CN">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>VOXIN Â· æµ…è‰²ç‰ˆ</title>
  <style>
    :root{
      --bg:#ffffff;          /* é¡µé¢èƒŒæ™¯ */
      --card:#f8fafc;        /* å¡ç‰‡èƒŒæ™¯ */
      --soft:#e5e7eb;        /* æŸ”å’Œåˆ†éš”çº¿ */
      --text:#0f172a;        /* ä¸»æ–‡å­— */
      --muted:#475569;       /* æ¬¡çº§æ–‡å­— */
      --accent:#2563eb;      /* ä¸»æŒ‰é’®/é«˜äº® */
      --accent2:#06b6d4;     /* é¢‘è°±è‰²ï¼ˆå·²ç”¨äºåœ†ç¯å³ä¾§ï¼‰ */
      --danger:#ef4444;      /* å±é™©è‰² */
    }
    *{box-sizing:border-box}
    html,body{margin:0;padding:0;background:var(--bg);color:var(--text);font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial}
    .wrap{max-width:760px;margin:0 auto;padding:16px}
    h1{font-size:22px;margin:8px 0 6px}
    .sub{color:var(--muted);font-size:13px}
    .card{background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 2px 14px rgba(15,23,42,.06);padding:12px;overflow: hidden;}
    .row{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
    button,select,input[type=range]{appearance:none;border:none}
    button{padding:10px 14px;border-radius:12px;color:#fff;background:var(--accent);font-weight:600;cursor:pointer}
    button.secondary{background:#e2e8f0;color:#0f172a}
    button.danger{background:var(--danger);color:#fff}
    button.ghost{background:transparent;color:var(--muted);border:1px solid var(--soft)}
    button:disabled{opacity:.6}
    select{padding:10px;border-radius:10px;background:#f1f5f9;color:#0f172a;border:1px solid var(--soft)}
    label{font-size:13px;color:var(--muted)}
    .slider{width:100%}
    .grid{display:grid;grid-template-columns:1fr;gap:12px}
    .hint{font-size:12px;color:#64748b}
    .pill{display:inline-block;font-size:12px;padding:4px 8px;border-radius:999px;background:#eef2f7;border:1px solid #d1d5db;color:#0f172a}
    canvas{display:block;width:100%;height:200px;border-radius:12px;background:#f1f5f9;border:1px solid var(--soft)}
    .badge{font-size:12px;color:#334155}
    .footer{font-size:12px;color:#64748b;text-align:center;margin-top:16px}
    @media (min-width:720px){canvas#wave{height:260px}}

    /* ç„¦ç‚¹å¯è§æ€§ */
    button:focus,select:focus,input:focus{outline:3px solid rgba(37,99,235,.35);outline-offset:2px}

    /* â€”â€” å¼¹çª— â€”â€” */
    .modal{position:fixed;inset:0;background:rgba(15,23,42,.45);display:none;align-items:center;justify-content:center;padding:16px;z-index:50}
    .modal[aria-hidden="false"]{display:flex}
    .modal-card{width:100%;max-width:460px;background:var(--card);border:1px solid var(--soft);border-radius:16px;box-shadow:0 10px 30px rgba(15,23,42,.2);padding:16px}
    .modal-card h3{margin:4px 0 6px;font-size:18px}
    .modal-card p{margin:0 0 10px;color:var(--muted)}

    .ring-wrap{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr)); /* å§‹ç»ˆä¸¤åˆ— */
      gap:8px;
      align-items:stretch;
    }

    .ring{
      display:flex;
      align-items:center;
      justify-content:center;
      background:#f1f5f9;
      border:1px solid var(--soft);
      border-radius:12px;

      aspect-ratio: 1 / 1;  /* æ­£æ–¹å½¢ï¼Œé¿å…æ¤­åœ† */
      width:100%;           /* è·Ÿéšç½‘æ ¼ç­‰åˆ† */
      /* ä¸è¦å›ºå®š/æœ€å°é«˜åº¦ï¼Œäº¤ç»™ aspect-ratio å’Œå®½åº¦å†³å®š */
    }

    /* é‡è¦ï¼šä¸è¦ç”¨ 100%/100% æ‹‰ä¼¸ canvasï¼Œäº¤ç»™ JS æ¥è®¾å°ºå¯¸ */
    .ring canvas{
      background:transparent;
      border:none;
      border-radius:12px;
      width:auto;
      height:auto;
      display:block;
    }


  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>VOXIN - å¼€å¯ä½ çš„å£°éŸ³è®­ç»ƒä¹‹æ—…å§ï¼ğŸ¤âœ¨ğŸš€</h1>
      <div class="sub">
        <span id="supportHint" class="hint" style="display:block;margin-top:4px"></span>
      </div>
    </header>

    <section class="card" id="displayCard">
      <div class="row" style="justify-content:space-between;margin-bottom:8px">
        <span class="badge" id="sr">é‡‡æ ·ç‡: â€”</span>
        <span class="pill" id="peak">å³°å€¼: 0%</span>
      </div>
      <canvas id="wave"></canvas>

      <!-- â–¼â–¼â–¼ æ›¿æ¢æ‰åŸå…ˆçš„ spectrumï¼šåŒåœ†ç¯ â–¼â–¼â–¼ -->
      <div class="ring-wrap" style="margin-top:12px">
        <div class="ring"><canvas id="ringJitter" aria-label="jitter_local_percent"></canvas></div>
        <div class="ring"><canvas id="ringShimmer" aria-label="shimmer_local_percent"></canvas></div>
      </div>
      <!-- â–²â–²â–² æ›¿æ¢ç»“æŸ â–²â–²â–² -->
    </section>

    <section class="grid" style="margin-top:12px">
      <div class="card">
        <div class="row" style="justify-content:space-between">
          <div class="row">
            <button id="toggle">å¼€å§‹</button>
            <button class="secondary" id="reenum">åˆ·æ–°è®¾å¤‡</button>
          </div>
          <div class="badge" id="ctxState"></div>
        </div>

        <div style="height:8px"></div>
        <div class="row">
          <label for="mics">éº¦å…‹é£</label>
          <select id="mics"></select>
        </div>

        <div class="row" style="gap:16px;margin-top:8px">
          <div style="flex:1;min-width:140px">
            <label>å¹³æ»‘ (smoothing) <span id="smoothingVal" class="badge">0.50</span></label>
            <input class="slider" id="smoothing" type="range" min="0" max="0.95" step="0.01" value="0.5" />
          </div>
          <div style="flex:1;min-width:140px">
            <label>å¢ç›Š (gain) <span id="gainVal" class="badge">1.0</span></label>
            <input class="slider" id="gain" type="range" min="0.1" max="3" step="0.1" value="1" />
          </div>
          <div style="flex:1;min-width:140px">
            <label>æ³¢å½¢ç¼©æ”¾ (scope) <span id="scopeVal" class="badge">1.00Ã—</span></label>
            <input class="slider" id="scope" type="range" min="0.25" max="100" step="0.25" value="50" />
          </div>
        </div>
      </div>
    </section>

    <div class="footer">Â© <span id="year"></span> VOXIN Demo</div>
  </div>

  <!-- ç»“æœå¼¹çª—ï¼šä¸‹è½½ / ä¸Šä¼  -->
  <div class="modal" id="resultModal" aria-hidden="true" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
    <div class="modal-card">
      <h3 id="modalTitle">å½•éŸ³å®Œæˆ âœ…</h3>
      <div style="margin:10px 0">
        <label for="filenameInput" class="hint">è¯·è¾“å…¥æ–‡ä»¶å(ä¾‹å¦‚ï¼šjack_pre, jack_post)</label>
        <input type="text" id="filenameInput" placeholder="æ–‡ä»¶å" style="width:100%;padding:8px;border:1px solid #d1d5db;border-radius:8px;font-size:14px;margin-top:4px" />
      </div>
      <div class="row" style="justify-content:flex-end">
        <button class="secondary" id="btnUpload">ä¸Šä¼ </button>
        <button id="btnDownload">ä¸‹è½½</button>
      </div>
      <div id="uploadStatus" class="hint" style="margin-top:8px"></div>
    </div>
  </div>

<script>
(function(){
  // ===== Polyfill: æ—§ç‰ˆæµè§ˆå™¨çš„ getUserMedia =====
  (function ensureGetUserMedia(){
    if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
      navigator.mediaDevices.getUserMedia({ audio: true })
        .then(stream => { console.log("éº¦å…‹é£é‡‡é›†æˆåŠŸ", stream); })
        .catch(err => { console.error("éº¦å…‹é£é‡‡é›†å¤±è´¥:", err); });
    } else {
      console.error("è¯¥æµè§ˆå™¨ä¸æ”¯æŒéº¦å…‹é£é‡‡é›†");
    }
  })();

  const dpr = window.devicePixelRatio || 1;
  const wave = document.getElementById('wave');
  const ringJitter = document.getElementById('ringJitter');
  const ringShimmer = document.getElementById('ringShimmer');
  const toggleBtn = document.getElementById('toggle');
  const reenumBtn = document.getElementById('reenum');
  const micsSel = document.getElementById('mics');
  const smoothingInp = document.getElementById('smoothing');
  const gainInp = document.getElementById('gain');
  const smoothingVal = document.getElementById('smoothingVal');
  const gainVal = document.getElementById('gainVal');
  const scopeInp = document.getElementById('scope');
  const scopeVal = document.getElementById('scopeVal');
  const srEl = document.getElementById('sr');
  const peakEl = document.getElementById('peak');
  const ctxState = document.getElementById('ctxState');
  const yearEl = document.getElementById('year');
  const supportHint = document.getElementById('supportHint');
  yearEl.textContent = new Date().getFullYear();

  // â€”â€” å¼¹çª—å…ƒç´  â€”â€” 
  const modal = document.getElementById('resultModal');
  const btnDownload = document.getElementById('btnDownload');
  const btnUpload = document.getElementById('btnUpload');
  const uploadStatus = document.getElementById('uploadStatus');
  const filenameInput = document.getElementById('filenameInput');

  // â€”â€” å½•éŸ³å™¨ â€”â€” 
  let mediaRecorder = null;
  let lastRecording = null; // { blob, mime, filename }

  let ac = null, analyser = null, gainNode = null, src = null, stream = null, raf = null;

  // â€”â€” ç¯å½¢ç¼“å†²ï¼ˆå†å²æ³¢å½¢ï¼‰ï¼Œé»˜è®¤ 30 ç§’ â€”â€” 
  let windowSec = 30;
  let ring = null, ringLen = 0, writeIdx = 0, totalWritten = 0, tdFloat = null;

  // â€”â€” åœ†ç¯çŠ¶æ€ â€”â€” 
  const state = {
    jitterPercent: 0,   // 0-?
    shimmerPercent: 0,  // 0-?
    ewmaJ: 0,
    ewmaS: 0
  };

  // åŸºç¡€ç¯å¢ƒæç¤º
  const isSecure = location.protocol === 'https:' || location.hostname === 'localhost' || location.hostname === '127.0.0.1';
  if (!isSecure) {
    supportHint.textContent = 'âš ï¸ éå®‰å…¨ç¯å¢ƒï¼šè¯·ä½¿ç”¨ HTTPS æˆ– localhostã€‚';
  }

  function resizeCanvas(c){
    const rect = c.parentElement ? c.parentElement.getBoundingClientRect() : {width: c.clientWidth};
    const cssW = Math.floor(rect.width);
    const cssH = Math.max(160, Math.floor(cssW * 0.4));
    if (c === wave) {
      c.style.height = cssH + 'px';
    }
    c.width  = Math.floor((c === wave ? cssW : Math.min(cssW, 360)) * dpr);
    c.height = Math.floor((c === wave ? Math.max(160, Math.floor(cssW * 0.4)) : Math.min(c.parentElement.clientHeight, 420)) * dpr);
  }

  function resizeRing(c){
    const rect = c.parentElement.getBoundingClientRect();
    // è‹¥é«˜åº¦æœªå®šï¼Œç”¨å®½åº¦å…œåº•ï¼ˆaspect-ratio ä¼šè®©æœ€ç»ˆé«˜åº¦â‰ˆå®½åº¦ï¼‰
    let sizeCss = Math.floor(rect.width);
    if (rect.height && rect.height > 0) {
      sizeCss = Math.floor(Math.min(rect.width, rect.height));
    }

    // å±•ç¤ºå°ºå¯¸ï¼ˆCSS åƒç´ ï¼‰
    c.style.width  = sizeCss + 'px';
    c.style.height = sizeCss + 'px';

    // ç»˜å›¾åƒç´ ï¼ˆç‰©ç†åƒç´ ï¼‰
    const dpr = window.devicePixelRatio || 1;
    c.width  = Math.floor(sizeCss * dpr);
    c.height = Math.floor(sizeCss * dpr);
  }



  const onResize = ()=>{
    resizeCanvas(wave);
    resizeRing(ringJitter);
    resizeRing(ringShimmer);
  };
  window.addEventListener('resize', onResize);
  onResize();

  async function enumerate(){
    if (!(navigator.mediaDevices && navigator.mediaDevices.enumerateDevices)) {
      micsSel.innerHTML = '<option value="">é»˜è®¤éº¦å…‹é£ï¼ˆè®¾å¤‡åˆ‡æ¢ä¸å¯ç”¨ï¼‰</option>';
      return;
    }
    try{
      const tmp = await navigator.mediaDevices.getUserMedia({audio:true});
      tmp.getTracks().forEach(t=>t.stop());
      const list = await navigator.mediaDevices.enumerateDevices();
      const mics = list.filter(d=>d.kind==='audioinput');
      const opts = mics.map((d,i)=>`<option value="${d.deviceId||''}">${d.label||`éº¦å…‹é£ ${i+1}`}</option>`).join('');
      micsSel.innerHTML = opts || '<option value="">é»˜è®¤éº¦å…‹é£ï¼ˆæœªåˆ—å‡ºè®¾å¤‡ï¼‰</option>';
    }catch(e){
      micsSel.innerHTML='<option value="">é»˜è®¤éº¦å…‹é£</option>';
    }
  }
  enumerate();

  function getTimestamp() {
    const d = new Date();
    const pad = n => n.toString().padStart(2, '0');
    return [
      d.getFullYear(),
      pad(d.getMonth() + 1),
      pad(d.getDate()),
      pad(d.getHours()),
      pad(d.getMinutes()),
      pad(d.getSeconds())
    ].join('_');
  }

  // ===== ä¼°è®¡ Jitter/Shimmerï¼ˆåŸºäºæœ€è¿‘1ç§’ï¼Œç®€åŒ–æ³•ï¼‰ =====
  // TODO: ç»´æŠ¤ä¸€ä¸ªé•¿çª—ï¼Œæ¯”å¦‚è¿‡å»3â€“5ç§’çš„å…¨å±€å‡å€¼
  function estimateMetrics(rbuf, writeIdx, sr){
    const secs = 0.6; // 0.5~0.8s éƒ½å¯ä»¥
    const N = Math.min(rbuf.length, Math.floor(sr * secs));
    if (N < 1024) return { jitterP: 0, shimmerP: 0, ok:false };

    // æ‹·è´æœ€è¿‘ N ä¸ªæ ·æœ¬å¹¶ç®— RMS
    const buf = new Float32Array(N);
    let start = (writeIdx - N + rbuf.length) % rbuf.length;
    let s2 = 0;
    for (let i=0;i<N;i++){ const v=rbuf[(start+i)%rbuf.length]; buf[i]=v; s2+=v*v; }
    const rms = Math.sqrt(s2/N);
    if (rms < 0.003) return { jitterP:0, shimmerP:0, ok:false }; // é™éŸ³ç›´æ¥ä¸è®¡

    // â€”â€” è‡ªç›¸å…³æ‰¾åŸºéŸ³ï¼ˆ50â€“500Hzï¼‰ â€”â€” //
    const minLag = Math.floor(sr/500), maxLag = Math.ceil(sr/50);
    let bestLag=-1, bestR=0;
    for (let lag=minLag; lag<=maxLag; lag++){
      let num=0, d1=0, d2=0;
      for (let i=lag;i<N;i++){ const a=buf[i], b=buf[i-lag]; num+=a*b; d1+=a*a; d2+=b*b; }
      const r = num / Math.sqrt(d1*d2 + 1e-12);
      if (r > bestR){ bestR=r; bestLag=lag; }
    }
    if (bestR < 0.6 || bestLag < 0) return { jitterP:0, shimmerP:0, ok:false };

    // åœ¨ Â±15% çª—å†…æ‰¾è¿ç»­å‘¨æœŸè¾¹ç•Œï¼ˆå³°ï¼‰
    const lo = Math.floor(bestLag*0.85), hi = Math.ceil(bestLag*1.15);
    const peaks = [];
    for (let i=bestLag; i<N-hi; ){
      let localBest=i, localMax=-1e9;
      for (let lag=lo; lag<=hi; lag++){
        const j=i+lag; if (j>=N) break;
        const v=Math.abs(buf[j]);
        if (v>localMax){ localMax=v; localBest=j; }
      }
      peaks.push(localBest);
      i=localBest;
    }
    if (peaks.length < 8) return { jitterP:0, shimmerP:0, ok:false };

    // å‘¨æœŸä¸æ¯å‘¨æœŸå¹…åº¦ï¼ˆå³°-å³°ï¼‰
    const periods=[], amps=[];
    for (let k=1;k<peaks.length;k++){
      const a=peaks[k-1], b=peaks[k];
      const L=b-a;
      if (L<minLag || L>maxLag) continue;
      periods.push(L);

      let maxV=-1e9, minV=1e9;
      for (let t=a;t<b;t++){ const v=buf[t]; if(v>maxV)maxV=v; if(v<minV)minV=v; }
      amps.push(Math.max(1e-9, maxV-minV));
    }
    const n = periods.length;
    if (n < 7) return { jitterP:0, shimmerP:0, ok:false };

    const mean = arr => arr.reduce((s,v)=>s+v,0)/arr.length;
    const mP = mean(periods), mA = mean(amps);

    // â€”â€” PPQ5ï¼šæ¯ä¸ªå‘¨æœŸä¸å…¶å‰åå„2ä¸ªï¼Œå…±5ä¸ªå‘¨æœŸå‡å€¼çš„å·® â€”â€” //
    let sumPPQ5 = 0, cPPQ5 = 0;
    for (let i=2; i<=n-3; i++){
      const localMeanP = (periods[i-2]+periods[i-1]+periods[i]+periods[i+1]+periods[i+2])/5;
      sumPPQ5 += Math.abs(periods[i] - localMeanP);
      cPPQ5++;
    }
    const jPPQ5 = (cPPQ5 ? (sumPPQ5/cPPQ5) : 0) / mP; // æ¯”ä¸Šå…¨å±€å‡å€¼

    // â€”â€” APQ5ï¼ˆShimmerï¼‰ï¼šå¯¹æ¯å‘¨æœŸå¹…åº¦åšåŒæ ·çš„ 5 ç‚¹å¹³å‡å·® â€”â€” //
    let sumAPQ5 = 0, cAPQ5 = 0;
    for (let i=2; i<=amps.length-3; i++){
      const localMeanA = (amps[i-2]+amps[i-1]+amps[i]+amps[i+1]+amps[i+2])/5;
      sumAPQ5 += Math.abs(amps[i] - localMeanA);
      cAPQ5++;
    }
    const sAPQ5 = (cAPQ5 ? (sumAPQ5/cAPQ5) : 0) / mA;

    return {
      // ç™¾åˆ†æ¯”å¹¶é™åˆ¶åˆç†é‡ç¨‹ï¼šPPQ5 å¸¸è§ < 2%ï¼ŒAPQ5 å¸¸è§ < 10â€“15%
      jitterP:  Math.max(0, Math.min(10,  jPPQ5 * 100)),
      shimmerP: Math.max(0, Math.min(20, sAPQ5 * 100)),
      ok: true
    };
  }



  // ===== åœ†ç¯ç»˜åˆ¶ =====
  function drawRing(canvas, value, label, color, maxP){
    const ctx = canvas.getContext('2d');
    const W = canvas.width, H = canvas.height;
    const cx = W/2, cy = H/2;
    const r = Math.min(W, H) * 0.36;
    const lw = Math.max(8, Math.round(r*0.22));

    ctx.clearRect(0,0,W,H);

    // èƒŒæ™¯ç¯
    ctx.lineCap = 'round';
    ctx.lineWidth = lw;
    ctx.strokeStyle = '#e2e8f0';
    ctx.beginPath();
    ctx.arc(cx, cy, r, -Math.PI*0.75, Math.PI*0.75);
    ctx.stroke();

    // æ•°å€¼ç¯
    const ratio = Math.max(0, Math.min(1, value / (maxP || 10)));
    const start = -Math.PI*0.75;
    const end = start + ratio * (Math.PI*1.5);
    ctx.strokeStyle = color;
    ctx.beginPath();
    ctx.arc(cx, cy, r, start, end);
    ctx.stroke();

    // ä¸­å¿ƒæ–‡å­—
    ctx.fillStyle = '#0f172a';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';

    const valStr = value.toFixed(2) + '%';
    ctx.font = Math.round(r*0.4) + 'px system-ui,-apple-system,Segoe UI,Roboto';
    ctx.fillText(valStr, cx, cy - r*0.05);

    ctx.fillStyle = '#475569';
    ctx.font = Math.round(r*0.22) + 'px system-ui,-apple-system,Segoe UI,Roboto';
    ctx.fillText(label, cx, cy + r*0.6);
  }


  async function start(){
    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
      alert('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒæˆ–æœªå¯ç”¨éº¦å…‹é£é‡‡é›†ï¼ˆç¼ºå°‘ navigator.mediaDevices.getUserMediaï¼‰ã€‚è¯·å‡çº§ç³»ç»Ÿ/æµè§ˆå™¨ï¼Œæˆ–æ”¹ç”¨ Safari/ç³»ç»Ÿæµè§ˆå™¨ã€‚');
      return;
    }

    toggleBtn.disabled = true;
    try{
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) {
        throw new Error('æ­¤æµè§ˆå™¨ä¸æ”¯æŒ Web Audio APIï¼ˆç¼ºå°‘ AudioContextï¼‰ã€‚');
      }

      ac = new AudioCtx();
      if(ac.state==='suspended') await ac.resume();
      ctxState.textContent=ac.state;
      ac.onstatechange = (e) => {
        if (ctxState && e && e.target) ctxState.textContent = e.target.state;
      };

      const baseConstraints = { audio: true };
      let constraints = baseConstraints;

      const canSelectDevice = !!(micsSel && micsSel.value && micsSel.value !== '');
      if (canSelectDevice) {
        constraints = {
          audio: {
            deviceId: { exact: micsSel.value },
            echoCancellation:false, noiseSuppression:false, autoGainControl:false
          }
        };
      } else {
        constraints = { audio: { echoCancellation:false, noiseSuppression:false, autoGainControl:false } };
      }

      try { stream = await navigator.mediaDevices.getUserMedia(constraints); }
      catch (err) { stream = await navigator.mediaDevices.getUserMedia(baseConstraints); }

      src = ac.createMediaStreamSource(stream);
      analyser = ac.createAnalyser();
      analyser.fftSize = 2048;
      analyser.smoothingTimeConstant = parseFloat(smoothingInp.value);

      gainNode = ac.createGain();
      gainNode.gain.value = parseFloat(gainInp.value);

      src.connect(gainNode).connect(analyser);

      srEl.textContent = 'é‡‡æ ·ç‡: ' + ac.sampleRate + ' Hz';

      // åˆå§‹åŒ–ç¯å½¢ç¼“å†²
      ringLen = Math.ceil(ac.sampleRate * windowSec * 1.2);
      ring = new Float32Array(ringLen);
      writeIdx = 0; totalWritten = 0;
      tdFloat = new Float32Array(analyser.fftSize);
      const fd = new Uint8Array(analyser.frequencyBinCount); // ä»ç”¨äºå³°å€¼ç²—ä¼°

      function draw(){
        const wctx = wave.getContext('2d');
        const W = wave.width, H = wave.height;

        // çº¿å®½è·Ÿéš DPR
        wctx.lineWidth = Math.max(1, dpr);

        // èƒŒæ™¯ä¸ä¸­çº¿ï¼ˆæµ…è‰²ï¼‰
        wctx.clearRect(0,0,W,H);
        wctx.fillStyle = '#ffffff'; wctx.fillRect(0,0,W,H);
        wctx.strokeStyle = '#cbd5e1'; wctx.beginPath(); wctx.moveTo(0,H/2); wctx.lineTo(W,H/2); wctx.stroke();

        // æ”¶é›†ä¸€å¸§
        analyser.getFloatTimeDomainData(tdFloat);
        let pk = 0;
        for (let i = 0; i < tdFloat.length; i++) {
          const v = tdFloat[i];
          ring[writeIdx] = v;
          writeIdx = (writeIdx + 1) % ringLen;
          totalWritten++;
          if (Math.abs(v) > pk) pk = Math.abs(v);
        }
        peakEl.textContent = 'å³°å€¼: ' + Math.min(100, Math.round(pk * 100)) + '%';

        // å›ºå®šç›®æ ‡çª—å£
        const targetSamples = Math.floor(ac.sampleRate * windowSec);
        const available = Math.min(totalWritten, targetSamples);
        const stride = Math.max(1, Math.floor(targetSamples / W));
        let startIdx = (writeIdx - available + ringLen) % ringLen;
        const visibleCols = Math.max(1, Math.floor(available / stride));
        const offsetX = W - visibleCols;
        const scope = scopeInp ? parseFloat(scopeInp.value) : 1;

        // æ³¢å½¢ï¼ˆç«–æ¡ï¼‰
        wctx.strokeStyle = '#2563eb';
        wctx.beginPath();
        for (let x = offsetX; x < W; x++) {
          let min =  1, max = -1;
          for (let k = 0; k < stride; k++) {
            const idx = (startIdx + (x - offsetX) * stride + k) % ringLen;
            let v = ring[idx] * scope;
            if (v >  1) v =  1;
            if (v < -1) v = -1;
            if (v < min) min = v;
            if (v > max) max = v;
          }
          const y1 = (1 - (max + 1) / 2) * H;
          const y2 = (1 - (min + 1) / 2) * H;
          wctx.moveTo(x, y1);
          wctx.lineTo(x, y2);
        }
        wctx.stroke();

        // === ä¼°è®¡ Jitter & Shimmerï¼Œå¹¶ç»˜åˆ¶ä¸¤ä¸ªåœ†ç¯ ===
        const { jitterP, shimmerP, ok } = estimateMetrics(ring, writeIdx, ac.sampleRate);
        // ç®€å•å¹³æ»‘ï¼ˆEWMAï¼‰é¿å…è·³åŠ¨
        const alpha = 0.8;
        if (ok){
          state.ewmaJ = alpha * jitterP + (1-alpha) * (state.ewmaJ || jitterP);
          state.ewmaS = alpha * shimmerP + (1-alpha) * (state.ewmaS || shimmerP);
          state.jitterPercent = state.ewmaJ;
          state.shimmerPercent = state.ewmaS;
        }

        // ç”»åœ†ç¯
        drawRing(ringJitter, state.jitterPercent || 0, 'Jitter', '#2563eb', 10);
        drawRing(ringShimmer, state.shimmerPercent || 0, 'Shimmer', '#06b6d4', 20);

        raf = requestAnimationFrame(draw);
      }

      raf = requestAnimationFrame(draw);
      toggleBtn.textContent = 'åœæ­¢';

      // å½•éŸ³èƒ½åŠ›
      if ('MediaRecorder' in window) {
        let options = {};
        // 1) å…ˆæŠŠ iOS Safari å¸¸ç”¨çš„ AAC in MP4 æ”¾åˆ°æœ€å‰ï¼ˆä¿å­˜ .m4aï¼‰
        // 2) å†ç»™ä¸€äº› Safari æŠ€æœ¯é¢„è§ˆ / å…¶å®ƒæµè§ˆå™¨å¯èƒ½æ”¯æŒçš„å¤‡é€‰
        const candidates = [
          'audio/mp4;codecs=mp4a.40.2', // iOS Safari é¦–é€‰ï¼šAAC in MP4ï¼ˆ.m4aï¼‰
          'audio/mp4',                  // æ¬¡é€‰ï¼ˆå¤šæ•°ä¹Ÿä¼šæ˜¯ AACï¼‰
          'audio/wav',                  // æ–°ç‰ˆ Safari TP å¯èƒ½æ”¯æŒ
          'audio/webm;codecs=opus',     // Chrome/Edge/Firefox å¸¸ç”¨
          'audio/webm',
          'audio/mpeg'                  // éƒ¨åˆ†æµè§ˆå™¨ï¼ˆé€šå¸¸èµ° MP3ï¼‰
        ];

        for (const t of candidates) {
          try {
            if (MediaRecorder.isTypeSupported(t)) { options.mimeType = t; break; }
          } catch(_) {}
        }

        try {
          const timesliceMs = 100; // å®šæ—¶å‡ºå—ï¼Œé¿å…æŸäº›å®ç°åªåœ¨ stop æ—¶åæ•°æ®
          mediaRecorder = new MediaRecorder(stream, options);
          console.log('ä½¿ç”¨ MediaRecorderï¼ŒMIME:', mediaRecorder.mimeType || options.mimeType || '(browser default)');

          let chunks = [];
          mediaRecorder.ondataavailable = (e) => {
            if (e.data && e.data.size > 0) chunks.push(e.data);
          };

          mediaRecorder.onstop = () => {
            if (chunks.length === 0) {
              console.warn('æ²¡æœ‰å½•éŸ³æ•°æ®å—');
              showModal();
              return;
            }

            const mime = mediaRecorder.mimeType || options.mimeType || 'application/octet-stream';
            const blob = new Blob(chunks, { type: mime });
            const ts = new Date().toISOString().replace(/[:.]/g,'-');

            // æ ¹æ®å®é™… MIME å†³å®šæ‰©å±•åï¼ˆå…³é”®ï¼šaudio/mp4 -> .m4aï¼‰
            let ext = 'bin';
            if (mime.includes('audio/mp4'))       ext = 'm4a';
            else if (mime.includes('audio/webm')) ext = 'webm';
            else if (mime.includes('audio/wav'))  ext = 'wav';
            else if (mime.includes('mpeg'))       ext = 'mp3';
            else if (mime.includes('ogg'))        ext = 'ogg';

            const filename = `record-${ts}.${ext}`;
            lastRecording = { blob, mime, filename };
            showModal();
          };

          mediaRecorder.start(timesliceMs);
        } catch (err) {
          console.error('MediaRecorder åˆ›å»ºå¤±è´¥:', err);
          mediaRecorder = null; // é™çº§ï¼šä¸å¯ç”¨å½•éŸ³
        }
      }

    }catch(e){
      alert((e && e.message) ? e.message :
            'å¯åŠ¨å¤±è´¥ï¼Œå¯èƒ½æ˜¯æœªæˆæƒéº¦å…‹é£ã€é HTTPSã€æˆ–æµè§ˆå™¨ä¸å…¼å®¹ã€‚');
      stop();
    }finally{
      toggleBtn.disabled = false;
    }
  }

  async function stop(){
      cancelAnimationFrame(raf); raf = null;
      
      // å…ˆåœæ­¢å½•éŸ³
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
          mediaRecorder.stop();
          // ç­‰å¾…ä¸€å°æ®µæ—¶é—´è®©æ•°æ®æ”¶é›†å®Œæˆ
          await new Promise(resolve => setTimeout(resolve, 200));
      }
      
      // ç„¶åå…³é—­å…¶ä»–èµ„æº
      try{ if (gainNode) gainNode.disconnect(); }catch(_){}
      try{ if (analyser) analyser.disconnect(); }catch(_){}
      try{ if (src) src.disconnect(); }catch(_){}
      try{ if (stream){ stream.getTracks().forEach(t=>t.stop()); } }catch(_){}
      try{
          if (ac){
              ac.onstatechange = null;
              await ac.close();
          }
      }catch(_){}

      ac = null; analyser = null; gainNode = null; src = null; stream = null;

      ctxState.textContent='';
      toggleBtn.textContent='å¼€å§‹';
      
      // å¦‚æœæ²¡æœ‰å½•éŸ³å™¨æˆ–è€…å½•éŸ³å™¨å·²ç»åœæ­¢ï¼Œç›´æ¥æ˜¾ç¤ºå¼¹çª—
      if (!mediaRecorder || mediaRecorder.state === 'inactive') {
          showModal();
      }
  }


  // â€”â€” å¼¹çª—é€»è¾‘ â€”â€” 
  function showModal(){
    modal.setAttribute('aria-hidden','false');
    uploadStatus.textContent = '';
    btnDownload.disabled = !lastRecording;
  }
  function hideModal(){ modal.setAttribute('aria-hidden','true'); }

  // ä¸‹è½½å½“å‰å½•éŸ³
  btnDownload.addEventListener('click', () => {
    if (!lastRecording) { alert('æ²¡æœ‰å¯ä¸‹è½½çš„å½•éŸ³ã€‚'); return; }
    if (!filenameInput.value.trim()) { alert('è¯·è¾“å…¥æ–‡ä»¶åã€‚'); return; }
    const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.${lastRecording.filename.split('.').pop()}`;

    const { blob } = lastRecording;
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = input_filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(()=>URL.revokeObjectURL(url), 1000);
  });

  // ä¸Šä¼ å½“å‰å½•éŸ³ï¼ˆè¯·æ›¿æ¢ä¸ºä½ çš„ä¸Šä¼ æ¥å£ï¼‰
  btnUpload.addEventListener('click', async () => {
    try{
      if (!lastRecording) { alert('æ²¡æœ‰å¯ä¸Šä¼ çš„å½•éŸ³ã€‚'); return; }
      if (!filenameInput.value.trim()) { alert('è¯·è¾“å…¥æ–‡ä»¶åã€‚'); return; }
      const input_filename = `${filenameInput.value.trim()}_${getTimestamp()}.${lastRecording.filename.split('.').pop()}`;

      uploadStatus.textContent = 'æ­£åœ¨ä¸Šä¼ â€¦';
      const ENDPOINT = 'https://www.iloveyouso.top/api/upload';
      const { blob, mime } = lastRecording;
      const fd = new FormData();
      fd.append('file', blob, input_filename);
      fd.append('mime', mime);
      const res = await fetch(ENDPOINT, { method:'POST', body: fd, headers: {
        'Accept': 'application/json',
      } });
      if (!res.ok) throw new Error('ä¸Šä¼ å¤±è´¥ï¼ŒçŠ¶æ€ç ï¼š' + res.status);
      const text = await res.text().catch(()=> '');
      console.log('ä¸Šä¼ å“åº”:', text);
      uploadStatus.textContent = 'ä¸Šä¼ æˆåŠŸï¼';
    }catch(err){
      uploadStatus.textContent = 'ä¸Šä¼ å¤±è´¥ï¼š' + (err && err.message ? err.message : err);
    }
  });

  modal.addEventListener('click', (e)=>{ if(e.target===modal) hideModal(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') hideModal(); });

  toggleBtn.addEventListener('click',()=>{ if(ac) stop(); else start(); });
  reenumBtn.addEventListener('click',enumerate);

  smoothingInp.addEventListener('input',()=>{
    const v = parseFloat(smoothingInp.value);
    smoothingVal.textContent = v.toFixed(2);
    if(analyser) analyser.smoothingTimeConstant = v;
  });
  gainInp.addEventListener('input',()=>{
    const v = parseFloat(gainInp.value);
    gainVal.textContent = v.toFixed(1);
    if(gainNode) gainNode.gain.value = v;
  });
  scopeInp && scopeInp.addEventListener('input', () => {
    const v = parseFloat(scopeInp.value);
    scopeVal.textContent = v.toFixed(2) + 'Ã—';
  });
})();
</script>
<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
<script>eruda.init();</script>
</body>
</html>
